\documentclass{amsart}

\input{decls}
\input{macros}
\setcounter{tocdepth}{1}
\usepackage[utf8]{inputenc}

\title{Semantics of Higher Inductive Types}

\author{Peter LeFanu Lumsdaine}
\author{Michael Shulman}

\begin{document}

\maketitle

\begin{abstract}
The now-standard homotopy-theoretic models of Voevodsky, Awodey--Warren, et al, show that dependent type theory is expressive enough to talk about homotopy-theoretic properties and constructions.
%
However, traditional type theory provides no way to \emph{construct} homotopically non-trivial types.

Higher Inductive Types (HITs) were introduced to remedy this gap (in conjunction with the Univalence Axiom).
%
They generalise ordinary inductive definitions, allowing constructors to produce not only points but \emph{paths} in the posited type.

Here we show that many homotopy-theoretic models of dependent type theory also model HITs, using a generalisation of the initial-algebra semantics of ordinary inductive types.
%
Precisely, we show that \todo{\ldots} .
\end{abstract}


\tableofcontents

\section{Introduction}

The homotopy-theoretic interpretation of constructive type theory~\cite{...}, like any bridge between previously unrelated subjects, allows ideas and theorems to percolate in both directions.
On the one hand, because any well-behaved homotopy theory admits a model of type theory, we can use formal type-theoretic methods to prove homotopy-theoretic theorems.
On the other hand, examination of these models suggests new principles that can be added to type theory, making it more powerful and expressive, and also increasing the range of homotopy-theoretic theorems that can be proven formally.
So far, there are two important new type-theoretic principles that have been suggested by homotopy-theoretic models.
The first is Voevodsky's \emph{univalence axiom}; this has been discussed in detail elsewhere~\cite{klv:ssetmodel}, and we will have very little to say about it in this paper.
Our concern here is with the second, known as \emph{higher inductive types (HITs)}.

The basic idea of HITs was initially conceived at the Oberwolfach meeting in February 2011 by the present authors along with Bauer and Warren.
The first real application of HITs was the second author's formalized proof that $\pi_1(\circtype)=\lZ$, using a HIT definition of the circle $\circtype$~\cite{ls:pi1s1}.
Since then, many people have contributed to the further development of HITs; we will summarize some of their contributions in \cref{sec:hit-apps} below.
The syntax and use of HITs is explained in detail in Chapter 6 of the Homotopy Type Theory book~\cite{hottbook}, while many of their recent applications can be found in its Chapter 8.

However, what is still missing from the literature is a proof that HITs really do exist in homotopy-theoretic models of type theory, analogous to the proofs in~\cite{klv:ssetmodel,shulman:invdia,shulman:elreedy} that the univalence axiom holds in (some) such models.
This is what we aim to provide in the present paper.
The central ideas of the construction were developed by the authors in the summer of 2011, and disseminated as talks and sketchy notes over the next few years, but have not been written out comprehensively until now.

\subsection{What are HITs?}
\label{sec:what-are-hits}

There are many different ways to motivate HITs.

From a homotopy-theoretic point of view, they provide a way to construct interesting homotopy types in type theory.
Homotopy type theory (with univalence, but without HITs) excels at proving formal theorems about \emph{general} homotopy types, such as the ``5-lemma'' for fibration sequences or an ``unstable octahedral axiom'' for composites of fibrations.
But it suffers from a paucity of ways to obtain \emph{particular} homotopy types, such as spheres, tori, manifolds, Eilenberg--MacLane spaces, etc.
Higher inductive types remedy this situation, and can be thought of a type-theoretic analogue of the basic homotopical notion of \emph{cell complexes}.
They include both ``small, concrete'' cell complexes, such as CW presentations of spheres and tori, and ``large, abstract'' cell complexes such as those appearing in the construction of Postnikov towers and localizations by Quillen's small object argument.
Moreover, they provide a concise language for speaking about the latter that avoids referring explicitly to small objects and transfinite compositions.
(From this perspective, ordinary inductive types are \emph{0-dimensional} cell complexes.)

From a type-theoretic point of view, HITs provide a way to postulate equalities and construct quotients, obviating the need for ``setoids'' and all their corresponding hassles.
Bishop~\cite{bishop:fca} famously claimed that to specify a \emph{set}, one must specify how to construct its elements, and also specify when two such elements are equal.
Ordinary inductive types in type theory excel at specifying how to construct the elements of a set, but leave no flexibility in how to specify their equalities.
The standard solution is to equip each type with a secondary ``type of equalities'', forming a structure called a \emph{setoid}; this mostly works but results in a terrific amount of bookkeeping to carry around the setoid equalities everywhere.
Instead, higher inductive types augment ordinary inductive types with a basic way to ``specify the equalities between elements''.
The resulting equalities are actual equalities in the Leibniz sense, hence require no bookkeeping; they are automatically respected by everything in sight.

From a category-theoretic point of view, HITs provide a concise language for presentations of monads.
It is well-known that categorically, ordinary inductive types are free algebras for polynomial endofunctors.
Here an ``algebra for an endofunctor'' $F$ means nothing more than an object $X$ with a map $FX \to X$.
If $F$ is additionally a \emph{monad}, then we also have ``monad-algebras'', for which the map $FX \to X$ must satisfy associativity and unitality conditions.
In well-behaved categories, every polynomial endofunctor $F$ gives rise to a \emph{free monad} $\freemonad{F}$, so that that $F$-endofunctor-algebras are equivalent to $\freemonad{F}$-monad-algebras; thus we could equally well say that ordinary inductive types are free algebras for free monads.
However, the monads that arise naturally in mathematics are usually not free; but they are \emph{presented}, meaning that they are a colimit in the category of monads of a diagram consisting of free monads.
Higher inductive types, then, provide free algebras for these more general \emph{presented} monads.

Note that the type-theoretic and category-theoretic motivations presented above say nothing about homotopy theory.
(Although they can be easily extended to do so: the homotopical analogue of a setoid is an $\infty$-groupoid in type theory~\cite{coquand...}, and homotopically presented monads are simply colimits in the $(\infty,1)$-category of $(\infty,1)$-monads.)
Indeed, higher inductive types \emph{could} have been invented completely independently of the homotopical interpretation of type theory.
Although historically, it was the first, homotopy-theoretic, motivation which gave rise to them, they are still interesting and highly nontrivial even in Extensional Type Theory, where there is no higher homotopical information.
In particular, they supply well-behaved quotients and free algebras of all sorts, going beyond what exists in elementary toposes, and even beyond what can be constructed in ZF set theory without the axiom of choice, while nevertheless remaining constructive (at least in many, and conjecturally all, senses of the word).


\subsection{Some examples of HITs}
\label{sec:hit-egs}

Recall that an ordinary \emph{inductive type} is specified by some number of \emph{constructors}, which take as input some data (possibly recursively involving the inductive type being defined) and output an element of the inductive type.
For instance, the natural numbers are generated by a constructor \fzero that requires no input and a constructor \fsucc that takes a natural number as input; the unit type is generated by a single constructor \ftt that requires no input; and the empty type is generated by no constructors at all.

Roughly speaking, a \emph{higher} inductive type can have these same sorts of constructor, but also ``constructors'' whose output is not an \emph{element} of the type being defined, but an \emph{equality} between two such elements.
In homotopy type theory, equalities are identified with \emph{paths}, and so we call this new sort of constructor a \emph{path-constructor}.
The old sort of constructors may then be called \emph{point-constructors} for clarity.

It is of central importance that the paths constructed by path-constructors, like the points constructed by point-constructors, are \emph{new} paths, not coinciding with any path that ``already existed''.
For example, consider perhaps the simplest nontrivial HIT, the \textbf{circle} $\circtype$: this is generated by one point-constructor, called \fbase, and one path-constructor, called \floop, which constructs a path from \fbase to \fbase.
Of course, we already knew that \fbase was equal to \fbase, by reflexivity; but the path given by \floop is a \emph{new} such path that is not equal to reflexivity.%
\footnote{More precisely, it is not \textit{a priori} equal to reflexivity.
  Actually \emph{proving} that it is not equal to reflexivity is analogous to proving that the injections of a sum type are disjoint, and requires the univalence axiom; see~\cite{hottbook,ls:pi1s1}.}
From the homotopical point of view, we are describing the circle $\circtype$ as a cell complex with one 0-cell (\fbase) and one 1-cell (\floop).

The existence of \floop also entails the existence of many other paths from \fbase to \fbase; for instance, we can compose \floop with itself (i.e.\ apply the transitivity of equality), or invert it (i.e.\ apply the symmetry of equality), and so on.
Saying that \floop is an inductive generator of $\circtype$ means that \emph{none} of these paths are (\textit{a priori}) equal to each other.
(The theorem that $\pi_1(\circtype)=\lZ$ amounts to showing that, in the presence of the univalence axiom, we get \emph{exactly} the paths $\floop^n$ for $n$ an integer.)

Of course, we can also add paths between points that were not previously equal at all.
For instance, the \textbf{interval} $I$ is generated by two point-constructors, \fzero and \fone, and one path-constructor \fseg which constructs a path from \fzero to \fone.
Unsurprisingly, this turns out to be equivalent to the unit type (but it is not completely boring either, e.g.\ its existence implies function extensionality).

Additionally, since we are interested not only in \emph{whether} two points are equal, but \emph{how many} paths there are between them, we also allow path-constructors which construct \emph{paths between paths}, or \emph{paths between paths between paths}, and so on.
Homotopically, these correspond to cells of higher dimension in a cell complex, and indeed any (finite) cell complex can be presented as a HIT.
For instance, the \textbf{torus} $\torustype$ has one point-constructor \fbase, two path-constructors $\fmerid_1$ and $\fmerid_2$ giving paths from \fbase to itself, and one ``2-path-constructor'' giving a path relating the composites of $\fmerid_1$ and $\fmerid_2$ in both orders.
And the \textbf{2-sphere} $\spheretype 2$ has one point-constructor \fbase and one 2-path-constructor \fsurf giving a path from the \emph{reflexivity} path of \fbase to itself.

The ability to assert equalities also means that we can construct \textbf{colimits} of types.
With ordinary inductive types we can construct coproducts (sum types) and an initial object (the empty type), but not other colimits such as coequalizers or pushouts.
With HITs, however, these are easy to do.

The real power of HITs starts to show itself when we introduce path-constructors with recursive inputs, analogous to recursive point-constructors like \fsucc for the natural numbers.
The first such example is the \textbf{squash} or \textbf{bracket type}~\cite{ab:bracket-types} of a type $A$, which is intended to be a type $\brck{A}$ that contains at most one element, and does so exactly if $A$ has an element.
We can define this as a HIT with one point-constructor that takes as input an element of $A$, and one path-constructor which gives for any two elements $x$ and $y$ \emph{of $\brck{A}$ itself}, a path from $x$ to $y$.
The point-constructor ensures that if $A$ is inhabited then so is $\brck{A}$, while the path-constructor ensures that $\brck{A}$ has no more than one element.%
\footnote{In homotopy type theory, the question is a little more subtle: in addition to ensuring that any two elements of $\brck{A}$ are related by a path, we would want to ensure that any two \emph{paths} are related by a 2-dimensional path, and so on.
  Fortunately, the single path-constructor of $\brck{A}$ is sufficient to ensure this automatically.}

The bracket type is also known as the \textbf{$(-1)$-truncation}: it universally truncates $A$ into a $(-1)$-type, a homotopy type that is contractible if inhabited.
We can also construct $n$-truncations for all higher $n$.
For instance, the \textbf{$0$-truncation} $\trunc 0 A$, also known as $\pi_0(A)$, has the same point-constructor as $\brck{A}$, along with a 2-path-constructor saying that for any two elements $x$ and $y$ of $\trunc 0 A$, and any two paths $p$ and $q$ from $x$ to $y$, there is a path from $p$ to $q$.
In homotopy theory, the $n$-truncations of a type are called its \emph{Postnikov tower}.

By including both recursive point-constructors and recursive path-constructors, we can directly construct \textbf{free algebras} of any desired sort.
For instance, the \textbf{free group} $\freegroup{A}$ on a type $A$
\mswarning{Of course, to make $\freegroup{A}$ a set, we need to truncate it.  Should we mention that or sweep it under the rug?}
is generated by one point-constructor taking input from $A$; three point-constructors taking respectively no input (the identity element), two inputs from $\freegroup{A}$ itself (the multiplication), and one input from $\freegroup{A}$ (the inversion); and various path-constructors asserting the group axioms.
The resulting induction principle of the HIT $\freegroup{A}$ says almost verbatim that it \emph{is} the free group on $A$.
In this way, HITs enable us to ``construct'' free structures of all sorts merely by asserting their universal property.

One final example will serve to suggest the extreme flexibility of HITs.
Let $f:A\to B$ be a given function and $X$ a type, and consider the HIT $\local{f}{X}$ with the following constructors: (1) a point-constructor taking input from $X$, (2) a point-constructor \fext taking as input a function $g:A\to \local{f}{X}$ and an element $b:B$, (3) a path-constructor saying that for any $g:A\to \local{f}{X}$ and $a:A$ we have $\fext(g,f(a))=g(a)$, and (4) a path-constructor saying that for any $h:B\to \local{f}{X}$ and $b:B$ we have $\fext(h\circ f,b)=h(b)$.
\mswarning{Of course, this isn't quite right, it's a qinv rather than an equivalence.}
Then $\local{f}{X}$ is none other than the \textbf{localization} of $X$ at $f$: the universal type equipped with a map from $X$ which is \textbf{$f$-local} in the sense that $(\blank\circ f):(\local{f}{X})^B \to (\local{f}{X})^A$ is an equivalence.
Localizations are ubiquitous in homotopy theory, generally being constructed as transfinite cell complexes with the small object argument; HITs allow us to construct them just like free groups, merely by asserting their universal property.


\subsection{Applications of HITs}
\label{sec:hit-apps}

To show the usefulness and fruitfulness of HITs, we briefly survey some known applications.
Many of these results can be found in~\cite{hottbook}.

A fair amount of work so far has concentrated on reproducing homotopy-theoretic calculations in type theory, such computations of homotopy groups of spheres.
Here the $n^{\mathrm{th}}$ homotopy group $\pi_n(X)$ of a type $X$ (equipped with a basepoint) is defined to be the $0$-truncation of its $n$-fold loop space $\Omega^n X$ (the latter being definable without HITs).
The first such computation, as mentioned above, was the second author's proof that $\pi_1(\circtype)=\lZ$, and also $\pi_n(\circtype)=0$ for $n>1$, by showing that in fact $\Omega \circtype = \lZ$.
Licata~\cite{ls:pi1s1} later improved this proof, isolating a general method now known as ``encode--decode'' for computing with loop spaces of HITs.
Using this method, he and Brunerie calculated $\pi_k(\spheretype n) = 0$ for $k<n$ and $\pi_n(\spheretype n) = \lZ$.
The first author and Brunerie used the Hopf fibration to show $\pi_3(\spheretype 2) = \lZ$, and Brunerie used the James construction to show $\pi_4(\spheretype 3) = \lZ/2$.

HITs have also proven useful in more abstract homotopy-theoretic theorems.
The first author proved the Freudenthal suspension theorem in type theory, and with Licata and Finster generalized it to the Blakers--Massey theorem; the role of HITs being to construct suspensions and pushouts (as well as define homotopy groups by truncation).
The second author proven the van Kampen theorem, and Hou developed the theory of covering spaces.
Licata and Finster~\cite{lf:emspaces} have constructed Eilenberg--MacLane spaces $K(G,n)$, enabling the represented definition of cohomology and verification of the Eilenberg--Steenrod axioms.
Finally, Voevodsky constructed the long exact sequence associated to a fibration, and the second author used this to construct the cohomological Serre spectral sequence.
There is every prospect that this formalization of homotopy theory in type theory will continue fruitfully.

As suggested above, HITs also have applications outside of homotopy theory.
Spitters and Rijke~\cite{rs:hottsets} have used HIT colimits to show that the subcategory of ``sets'' in homotopy type theory is a $\Pi W$-pretopos.
Note that these ``sets'' are just types whose Leibniz equality satisfies UIP, not ``setoids'' equipped with any additional equality structure.
Awodey has constructed a ``cumulative hierarchy'' of ``membership-based sets'' as a HIT, which satisfies a constructive version of the ZF axioms.
Bauer has defined a set of ``Cauchy real numbers'' as a HIT (more precisely, a higher inductive-inductive type) that, unlike a simple quotient of Cauchy sequences, is constructively Cauchy-complete.
And the second author has defined a constructive version of Conway's surreal numbers as a higher inductive-inductive type, generalizing Taylor's ``plump ordinals''.

Finally, HITs may even have direct applications to theoretical computer science.
Angiuli, Morehouse, Licata, and Harper~\cite{amlh:htpy-patch} have used them to model a theory of ``patches'' for version control systems.


\subsection{An outline of this paper}
\label{sec:outline}

Unlike for ordinary inductive types, there is not yet a general presentation of what ``a higher inductive type'' entails.
Some fairly general schemata have been given (some of which we will discuss), but none of them includes all the examples of higher inductive types that have been proposed.
In particular, this means that our semantic construction of HITs cannot yet be phrased as a single theorem.

However, the \emph{methods} that we present in this paper can in fact be applied to all proposed examples of HITs that we are aware of.
For this reason, and also for expositional clarity, the structure of this paper is largely example-based.

\todo{We can wait to write the rest until the rest of the paper settles down.}

\section{Type theory}
\label{sec:type-theory}

In this section we briefly review the basic type theory we will be using.
It has a couple unusual features which enable it to match our models more precisely, but as we will see, they can all be eliminated at the cost of turning some judgmental equalities into propositional ones.

Our base theory is a form of Martin-L\"of dependent type theory \emph{without} universes.
Some of our models (particularly the simplicial set model~\cite{klv:ssetmodel}) have universes, but not all of them are known to, and so since we have little need for universes in this paper, we omit them.
(It should be noted, however, that all the \emph{homotopy-theoretic} results about HITs mentioned in \cref{sec:hit-apps} require the presence of a universe satisfying the univalence axiom.)

The absence of universes means that we need a separate judgment ``$A \type$'' indicating that $A$ is a type.
A type family (or dependent type) indexed by $A$ is then described by a hypothetical judgment $\jd{x:A |- B(x) \type}$.
Any such family has a dependent product $\prd{x:A} B(x)$ satisfying the usual rules, including the $\eta$-rule $f \jdeq \lam{x}f(x)$.
As usual, if $B(x)$ is independent of $x$, we write $A\to B$ for $\prd{x:A} B(x)$.

Besides dependent products\footnote{And coinductive types, which we will not consider here.}, all standard type formers can be regarded as special cases of the general notion of \emph{inductive type} such as in~\cite{gimenez:recursion}.
We will use an \msnote*{Or whatever; I just chose something for now for definiteness}{Agda-like syntax} for describing inductive types.
For instance, we write the natural number type as
\indef{\lN}{
  \fzero : \lN \OR
  \fsucc : \lN \to \lN
}
\msnote{This syntax looks wonky without universes.}
and the dependent pair type $\sm{x:A} B(x)$ as
\indef{\sm{x:A} B(x)}{
  \fpair : \prd{x:A} B(x) \to \sm{x:A} B(x)
}
Note that as usual, the scope of $\prd{x:A}$ extends as far to the right as possible, so that $\prd{x:A} B(x) \to \sm{x:A} B(x)$ means $\prd{x:A} \big(B(x) \to \sm{x:A} B(x)\big)$.

We allow inductive types to contain both \emph{parameters} and \emph{indices}.
Having a \emph{parameter} means essentially that we define a whole family of inductive types all at once, and each member of the family is inductively defined on its own.
For instance, we can define the dependent-pair-type operation with $A$ and $B$ as parameters:
\msnote{What should the syntax be for type parameters in the absence of a universe?}
\indef{\sum \; (A \type) \; (\jd{x:A |- B(x)\type})}{
  \fpair : \prd{x:A} B(x) \to \sm{x:A} B(x)
}
This means that each type $\sm{x:A} B(x)$ has its own induction principle, even though we have defined all of them together at once.
Note that although we have no universes, we allow types and type families to appear as parameters in an inductive definition; this is justified by the coherence theorem of~\cite{lw:localuniv}.
\msnote{Is there a way to specify syntactically what sorts of ``type family parameters'' are allowed?}

Having an \emph{index} means that we define a family of types by induction together, so that rather than each member of the family having an induction principle, the family as a whole has one induction principle.
Syntactically, the difference is that the constructors can take input from one element of the type family and give output in another, such as the standard inductive definition of length-indexed lists (vectors):%
\msnote{Once again, the syntax looks wonky.}
\indeff{\fVec \; (A\type)}{\lN\to\fType}{
  \fnil : \fVec_A(0) \OR
  \fcons : \prd{n:\lN} A \to \fVec_A(n) \to \fVec_A(n+1)
}
Here $A$ is a parameter and $n:\lN$ is an index.

The most important inductively defined family is the \emph{identity type}.\msnote{Mention ML vs PM?}
\indeff{\fId \; (A\type)}{A\to A\to \fType}{
  \refl : \prd{x:A} \id[A]xx
}
The distinguishing feature of \emph{homotopy} type theory is that the identity type $\id[A]xx$ can contain paths other than $\refl$, corresponding to loops in $A$ viewed as a ``space''.
For this reason we will sometimes refer to elements of an identity type as \emph{paths}.

As we will see in \cref{sec:hott-semantics}, it follows directly from the work in~\cite{lw:localuniv} that all of our models contain $\sum$-types and $\fId$-types.
However, in general this is not immediately obvious even for very simple ordinary inductive types such as $\lN$; it will follow as a degenerate case of our semantics for HITs.

As we will see in \cref{sec:syntax}, in order to state the induction principles for HITs we require the notion of \emph{path over a path} or \emph{dependent path}.
This means that given a type $A$ and a type family $B$ over $A$, for points $x,y:A$ and a path $e:\id[A]xy$ and points $u:B(x)$ and $v:B(y)$, we need to know what it means to say that ``$u$ and $v$ are related by a path (or an equality) over $e$''.
Note that the ordinary identity type cannot be applied to $u$ and $v$, since their types $B(x)$ and $B(y)$ are different; instead we need a new ``type of paths from $u$ to $v$ lying over $e$'' which we will write as $\idover[B]{u}{v}{e}$.
There are various ways to define this type, such as:
\begin{enumerate}
\item If we first define the \emph{transport} operation $\transf{e}:B(x) \to B(y)$ (using the eliminator for identity types), then we can define $\idover[B]{u}{v}{e}$ to be $\id[B(y)]{\transf{e}(u)}{v}$.
  This is the definition used by~\cite{hottbook} and the homotopy type theory Coq library.\label{item:idover1}
\item We could instead use $\id[B(x)]{u}{\transf{(\opp{e})}(v)}$, where $\opp{e}:\id[A]{y}{x}$ is the inverse path of $e$ (i.e.\ $\opp{(\blank)}$ witnesses the symmetry of equality).\label{item:idover2}
\item We could define $\idover[B]{u}{v}{e}$ by using the eliminator for identity types on $e$, with $\idover[B]{u}{v}{\refl_x}$ defined to be $\id[B(x)]{u}{v}$.
  This is the definition used by the homotopy type theory Agda library.\label{item:idover3}
\item We could define $\idover[B]{u}{v}{e}$ as an (ordinary) inductive family, with a single constructor saying that for any $x:A$ and $u:B(x)$ we have $\refl_u : \idover[B]{u}{u}{\refl_x}$.\label{item:idover4}
\end{enumerate}
These definitions all produce \emph{equivalent} types, but are not judgmentally identical.
In particular, they have different judgmental behavior: for instance, with~\ref{item:idover1}--\ref{item:idover3} we have $\idover[B]{u}{v}{\refl_x}$ judgmentally equal to $\id[B(x)]{u}{v}$, but with~\ref{item:idover4} this is not necessarily the case.
We will use definition~\ref{item:idover4} because it is more convenient in our models (see below); that is, we define:
\indeff{\fId \; (A\type)\; (\jd{x:A |- B(x)\type})}{\prd{x,y:A} \id[A]xy \to B(x) \to B(y) \to \fType}{
  \refl : \prd{x:A}{u:B(x)} \id[B]{u}{u}_{\refl_x}
}
We will also eventually need to use higher ``path-over-a-path-over-a-path'' types and so on, which we define analogously.

Finally, we include in our type theory a new primitive called \ap (for ``Action on Paths'' or ``APplication to a path''), with the following rules:
\[\inferrule{f:\tprd{x:A} B(x) \\ x:A \\ y:A}{\ap_f : \tprd{e:\id[A]xy} \idover[B]{f(x)}{f(y)}{e}}
\qquad
\inferrule{f:\tprd{x:A} B(x) \\ x:A}{\ap_f(\refl_x) \jdeq \refl_{f(x)}}
\]
It is, of course, possible to \emph{define} such an operation by identity elimination.
This defined operation, which we denote $\ap'$, plays an essential role in homotopy type theory, as developed in~\cite{hottbook} and elsewhere.
However, all of its occurrences could be replaced by a primitive $\ap$ without any real change, as long as the above two rules are satisfied.
Moreover, the shared computation rules $\ap_f(\refl_x) \jdeq \refl_{f(x)}$ and $\ap'_f(\refl_x) \jdeq \refl_{f(x)}$ imply that we always have an inhabitant of $\prd{e:\id[A]xy} \id{\ap_f(e)}{\ap'_f(e)}$, i.e.\ $\ap$ and $\ap'$ are propositionally equal.

The reasons for introducing the primitive $\ap$ are that (1) in our models, there is a ``naturally occurring'' operation satisfying the above rules which is not necessarily (judgmentally) identical to the defined $\ap'$, and (2) the rules for HITs take on a simpler form when expressed in terms of the naturally occurring $\ap$ --- specifically, their computation rules are judgmental.
In principle, however, it is always possible to re-express these rules in terms of $\ap'$ by inserting propositional equalities, obtaining a somewhat less convenient set of rules for HITs that we can model without the need for $\ap$.
We will explain this in the simpler cases, although it gets unbearably tedious for higher paths.


\section{Syntax of HITs}
\label{sec:syntax}

In this section we will describe the type-theoretic rules for higher inductive types, so that we know what we want to model in the semantics.
We will begin with simple specific examples and work up to fairly general ones (although, as we have said, a fully general specification of what should count as ``a higher inductive type'' is not yet known).

As mentioned in \cref{sec:hit-egs}, a higher inductive type is specified like an ordinary inductive type, except that in addition to \emph{point-constructors} whose ouput is an \emph{element} of the type being defined, we allow \emph{path-constructors} whose output is a \emph{path} (i.e.\ an equality) in that type.
We extend the syntax for describing inductive types from \cref{sec:type-theory} to include such path-constructors.
For instance, the higher inductive circle $\circtype$ can be written as
\indef{\circtype}{
  \fbase : \circtype \OR
  \floop : \id[\circtype]{\fbase}{\fbase}
}
and the $(-1)$-truncation $\brck{A}$ can be written as
\indef{\brck{A}}{
  \fproj : A \to \brck{A} \OR
  \fsquash : \prd{x,y:\brck{A}} \id[\brck{A}]{x}{y}
}
We may also allow higher path-constructors; for instance, the 2-sphere $\spheretype{2}$ can be written as
\indef{\spheretype{2}}{
  \fbase : \spheretype{2} \OR
  \fsurf : \id[{\id[\spheretype{2}]{\fbase}{\fbase}}]{\refl}{\refl}
}
while the torus $\torustype$ can be written as
\indef{\torustype}{
  \fbase : \torustype \OR
  \fmerid_1 : \id[\torustype]{\fbase}{\fbase} \OR
  \fmerid_2 : \id[\torustype]{\fbase}{\fbase} \OR
  \fsurf : \id[{\id[\torustype]{\fbase}{\fbase}}]{\fmerid_1 \ct \fmerid_2}{\fmerid_2 \ct \fmerid_1}
}
where $p\ct q$ denotes the concatenation of paths (i.e.\ the transitivity of equality).
In general, the \emph{domain} of a path-constructor is of the same form as the domain of a point-constructor (though we will discuss below some possible generalizations of this), while its \emph{codomain} is some iterated path-type of the HIT being constructed.

Note that specifying the codomain of a path-constructor requires specifying terms belonging to the HIT being defined and perhaps also to its iterated path-spaces.
For instance, in $\circtype$ we must specify $\fbase$ and $\fbase$ to be the source and target of the path $\floop$; while in $\torustype$ we must specify $\fbase$ and $\fbase$, and then also ${\fmerid_1 \ct \fmerid_2}$ and ${\fmerid_2 \ct \fmerid_1}$, to give the source and target of $\fsurf$.
These terms will often refer to other point- and perhaps path-constructors, such as $\fbase$ and $\fmerid_1$ and $\fmerid_2$.

This is a departure from ordinary inductive types, in which (at least usually) the type of each constructor must ``stand alone'' without referring to any other constructor.
It immediately presents us with the question of \emph{which} constructors can be referred to in specifying the type of a given constructor.
In this paper, we will always suppose that the constructors (both point- and path-) of a HIT are specified \emph{in an order}, and we allow the type of each constructor to refer only to those constructors appearing \emph{before} it; one can imagine relaxing this restriction, but it is not obvious whether our method for constructing semantics could handle such a relaxation.
Note that since point-constructors have no way to refer to other constructors at all, they might as well all be specified first.

There is an additional technical restriction on the terms ocurring in the codomain of a path-constructor, which we regard as vaguely analogous to the ``strict positivity'' condition on constructor domains: they must be \emph{natural}.
The meaning of this, and its importance, will be explained later.
\msnote{Say something more here once we decide how to deal with fibrancy?}%
(In fact, as we will see, this is one area where our current methods are not completely satisfactory.)

So much for how to \emph{specify} a HIT; how does such a type \emph{behave}?
In general, every type forming operation in type theory comes with \emph{formation}, \emph{introduction}, \emph{elimination}, and \emph{computation} rules.
The above specifications of HITs give us the \textbf{formation} rules easily; in these simple cases, the formation rule is just ``such-and-such type exists''.
Formation rules become a bit more complicated if we allow parameters and indices --- for instance, the type $A$ in $\brck{A}$ is best treated as a parameter, so that rather than just one HIT we have a different HIT $\brck{A}$ for each type $A$ --- but no new ideas are introduced here by HITs as compared with ordinary inductive types.

The \textbf{introduction rules} for a HIT are also easy: they are just the specified constructors.
For instance, the introduction rules for $\circtype$ say that we have $\fbase:\circtype$ and also $\floop : \id[\circtype]\fbase\fbase$.
It is essential
\msnote{Do we need to say more about why this makes sense?}%
that we regard $\floop$ as an introduction rule for $\circtype$ itself, rather than for $\id[\circtype]\fbase\fbase$, even though it is actually an element of the latter type; this will become clear when we discuss the elimination and computation rules.
Indeed, the type family $\id[\circtype]{x}{y}$ already has its \emph{own} introduction rule, namely $\refl: \prd{x:\circtype} \id[\circtype]{x}{x}$.

It is when we get to the \textbf{elimination rules} that things get interesting.
Elimination for ordinary inductive types can be specified either with an \emph{induction principle} or with \emph{pattern matching}.
From the perspective of categorical semantics, it appears necessary to regard the induction principle as basic, with pattern matching justified (insofar as possible) by reduction to the induction principle, as in~\cite{gmm:pattern-matching,cdp:without-k}.
It is not yet clear what a general formulation of pattern matching for HITs would look like.
Thus, in this paper we will concentrate on induction principles.

For an ordinary inductive type $W$, the induction principle says that for any type family $B$ over $W$, if we have operations on $B$ that correspond to, and ``live over'', each constructor of $W$, then we can define a function $f:\prd{x:W}B(x)$.
For instance, the induction principle for \lN says that if we have a type family $B$ over \lN equipped with $f_\fzero : B(\fzero)$ and $f_\fsucc : \prd{n:\lN} B(n) \to B(\fsucc(n))$, then we are entitled to $f:\prd{n:\lN} B(n)$.
We expect the induction principle for a HIT to be similar; the only question is what sort of operations on $B$ should be required to correspond to the path-constructors.
This is the role of the \emph{dependent path} type introduced in \cref{sec:type-theory}.

Consider, for example, the interval:
\indef{I}{
  \fzero : I \OR
  \fone : I \OR
  \fseg : \id[I]{\fzero}{\fone}
}
We expect the premises of its induction principle to include $f_\fzero : B(\fzero)$ and $f_\fone : B(\fone)$; but then corresponding to \fseg, we would expect some sort of path relating $f_\fzero$ to $f_\fone$.
We cannot even form a type ``$\id{f_\fzero}{f_\fone}$'' since $f_\fzero$ to $f_\fone$ have different types, but we \emph{can} ask for a dependent path $f_\fseg : \idover[B]{f_\fzero}{f_\fone}{\fseg}$.
Thus, the entire elimination rule for $I$ is
\[\inferrule{\jd{x:I |- B(x) \type} \\ f_\fzero : B(\fzero) \\ f_\fone : B(\fone) \\ f_\fseg : \idover[B]{f_\fzero}{f_\fone}{\fseg}}{\jd{x:I |- f(x) : B(x)}} \]

The general principle is thus that path-constructors in a HIT correspond to dependent path premises in its induction principle.
For instance, the circle $\circtype$ has the following elimination rule:
\[\inferrule{\jd{x:\circtype |- B(x) \type} \\ f_\fbase : B(\fbase) \\ f_\floop : \idover[B]{f_\fbase}{f_\fbase}{\floop}}{\jd{x:\circtype |- f(x) : B(x)}} \]
Note that in this case it would be possible to \emph{write} the non-dependent path type ``$\id[B(\fbase)]{f_\fbase}{f_\fbase}$'', but that this is \emph{not} the correct type for $f_\floop$.

Path-constructors with nontrivial domain are handled in the expected way, by dependent functions outputting dependent paths.
For instance, the \textbf{suspension} of a type $A$ is defined by
\indef{\susp A}{
  \fnorth : \susp A \OR
  \fsouth : \susp A \OR
  \fmerid : \prd{x:A} \id[\susp A]{\fnorth}{\fsouth}
}
Its induction principle is
\[\inferrule{\jd{x:\susp A |- B(x) \type} \\ f_\fnorth : B(\fnorth) \\ f_\fsouth : B(\fsouth) \\ f_\fmerid : \tprd{x:A} \idover[B]{f_\fnorth}{f_\fsouth}{\fmerid(x)}}
{\jd{x:\susp A |- f(x):B(x)}} \]
Similarly, path-constructors with recursive inputs correspond to inductive premises that take inputs from the induction motive.
For instance, the induction principle for the $(-1)$-truncation $\brck{A}$ is
\[\inferrule{\jd{x:\brck A |- B(x) \type} \\ f_\fproj : \tprd{a:A} B(\fproj(a)) \\ f_\fsquash : \tprd{x,y:\brck A}{u:B(x)}{v:B(y)} \idover[B]{u}{v}{\fsquash(x,y)}}
{\jd{x:\brck A |- f(x) : B(x)}}
\]
This should be compared with the familiar induction principle for the natural numbers:
\[ \inferrule{\jd{x:\lN |- B(x) \type} \\ f_\fzero : B(\fzero) \\ f_\fsucc : \tprd{x:\lN}{u:B(x)} B(\fsucc(x))}
{\jd{x:\lN |- f(x) : B(x)}}
\]
In both cases, each recursive argument to a constructor ($\fsucc$ or $\fsquash$) bifurcates into two arguments to the corresponding induction premise, one from the inductive type being defined and one from the induction motive.


\todo{Some simple specific examples: circle, suspension, torus, $(-1)$-truncation \ldots}

\todo{Possible variations, esp.\ judgementality of computation rules}

\todo{Define higher $W$-types, and conjecture their general expressivity}

\section{Semantics of HoTT}
\label{sec:hott-semantics}

\todo{Recall: comprehension categories, weakly stable structure, \ldots}

\todo{Give specific statement: ``Good model categories model HoTT.''}

\todo{While here, define/discuss any extra conditions on model categories we'll need.}

\todo{Recall: initial-algebra semantics of ITs.}

\section{Semantics of simple HITs}
\label{sec:simple-semantics}

\subsection{Circle}

As we did for inductive types above, to model the circle we first set up a (fibered) category of “algebras”, with a notion of “fibration”, and observe that a stably trivially cofibrant object in this category will model the rules for the circle.
%
In the case of the circle, it is then easy to construct such an object by hand.

\begin{definition}
A \emph{fibrant circle algebra} over $\Gamma \in \E$ is a fibration $X \fibto \Gamma$ equipped with a section $b : \Gamma \to X$, and a map $l : \Gamma \to \paths[\Gamma]{X}$ over $(b,b) : \Gamma \to X \times_\Gamma X$.
%
If $(X,b,l)$ is a fibrant circle algebra over $\Gamma$, then any $f : \Gamma' \to \Gamma$ induces a pullback fibrant circle algebra $f^*(X,b,l) := (f^*X,f^*b,f^*l)$ over $\Gamma'$.
\end{definition}

The formation and introduction rules say exactly that the circle $\circtype$ is a fibrant circle algebra over $1$.

\begin{definition}
A \emph{dependent circle algebra} over a fibrant circle algebra $(X,b,l)$ over $\Gamma$ consists of a fibration $Y \fibto X$, equipped with a map $\bbar : \Gamma \to Y$ over $b$, and a map $lbar : \Gamma \to \pathsover[\Gamma]{X}{Y}$ over $(\bbar,l,\bbar) : \Gamma \to Y \times_X \paths[\Gamma]{X} \times_X Y$. 
\end{definition}

The premises of the elimination and computation rules, in context $\Gamma$, posit precisely a dependent circle algebra over the pullback of $\circtype$ along $\Gamma \to 1$.

\begin{definition}
A \emph{(strict) section} of a dependent circle algebra $(Y,\bbar,\lbar)$ over $(X,b,l)$, $\Gamma$ is a section $s$ of the fibration $Y \fibto X$, such that $s(b) = \bbar$, $\paths[\Gamma]{s}(l) = \lbar$.

If $Y = (Y,\bbar,\lbar)$ is a dependent circle algebra over $X = (X,b,l)$, in context $\Gamma$, then pulling back along $f : \Gamma' \to \Gamma$ induces a dependent circle algebra $f^*Y$ over $f^*X$.
\end{definition}

The eliminator, together with the (judgemental) computation rules, provide a section for every dependent circle algebra over any pullback of  $\circtype$, along with stability conditions, which we disregard for now but will return to in Lemma~\ref{lemma:circle-coherence} below.
%
Based on this, we define:
\begin{definition}
A fibrant circle algebra is \emph{trivially cofibrant} if every dependent circle algebra over it has a section, and \emph{stably trivially cofibrant} if every pullback of it is trivially cofibrant.
\end{definition}

So far, we have set up these definitions following the syntactic presentation as closely as possible, and not relying on any features particular to the model-categorical setting.
%
However, in this setting---in particular, with strict functoriality of $\paths{-}$---these fit into a rather cleaner big picture:

\begin{definition}
There is an $\E$-indexed category $\Alg[\E]{\circtype}$, with an $\E$-indexed forgetful functor $U : \Alg[\E]{\circtype} \to \Eself$.

Objects of $\Alg[\E]{\circtype}$ consist of triples $(p:X \to \Gamma,b,l)$, as before, but with $p$ not assumed to be a fibration.
%
Maps of $(X',b',l') \to (X,b,l)$ in $\Alg[\E]{\circtype}(\Gamma)$ consist of maps $f : X' \to X$ over $\Gamma$, with $f(b') = b$, $\paths[\Gamma]{f}(l') = l$.

The functor $U$ sends a circle algebra $(X,b,l)$ over $\Gamma$ to its underlying map $p:X \to \Gamma$.

Moreover, $U$ induces an indexed subcategory of \emph{fibrations} in $\Alg[\E]{\circtype}$. 
\end{definition}

With this setting, a fibrant circle algebra over $\Gamma$, as originally defined, is exactly a fibrant object of $\Alg[\E]{\circtype}(\Gamma)$; a dependent circle algebra over $(X,b,l)$ is just a fibration over $(X,b,l)$ in $\Alg[\E]{\circtype}$; and a section of one is exactly a section in the usual sense.

\todo{Construct stable initial algebra as pushout; then, stably triv cof alg as fibrant replacement.}

\todo{State local universes lemma: “weakly stable triv cof alg in $\E$ gives strictly stable circle type in $\E_!$”.}

\subsection{Suspension}

\todo{Same pattern as for circle, but including fibrant replacement, and now only weakly stable}

\todo{Other simple examples?}

\subsection{Propositional truncation}
\todo{$(–1)$-truncation: set up the (now less trivial) category of algebras by hand. Note again that an initial one will model the types.}

\todo{Recall \emph{dialgebras}; recognise the algebras above as (iterated) dialgebras.}

\todo{Recall/give initial dialgebra theorems.  Conclude: we have models of the types.}

\section{Semantics of higher $W$-types}
\label{sec:higherw-semantics}

\todo{Set up endofunctors for iterated dialgebra construction.}

\todo{Note that initial dialgebras model higher $W$-types}

\todo{Note that we have initial dialgebras}

\section{Generalisations}
\label{sec:generalisations}

\todo{Higher path constructors, higher recursive calls, weakly natural sources and targets, induction-induction, induction-recursion, etc.}

\todo{How some of these (and simpler examples) can be reduced to higher W-types?}

\todo{Perhaps give or sketch semantics of some higher I-R type?}

\bibliographystyle{alpha}
\bibliography{basictex/all}

\end{document}
