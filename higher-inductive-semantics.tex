\documentclass{amsart}

\input{decls}
\input{macros}
\setcounter{tocdepth}{1}
\usepackage[utf8]{inputenc}

\title{Semantics of Higher Inductive Types}

\author{Peter LeFanu Lumsdaine}
\author{Michael Shulman}

\begin{document}

\maketitle

\begin{abstract}
The now-standard homotopy-theoretic models of Voevodsky, Awodey--Warren, et al, show that dependent type theory is expressive enough to talk about homotopy-theoretic properties and constructions.
%
However, traditional type theory provides no way to \emph{construct} homotopically non-trivial types.

Higher Inductive Types (HITs) were introduced to remedy this gap (in conjunction with the Univalence Axiom).
%
They generalise ordinary inductive definitions, allowing constructors to produce not only points but \emph{paths} in the posited type.

Here we show that many homotopy-theoretic models of dependent type theory also model HITs, using a generalisation of the initial-algebra semantics of ordinary inductive types.
%
Precisely, we show that \todo{\ldots} .
\end{abstract}


\tableofcontents

\section{Introduction}

The homotopy-theoretic interpretation of constructive type theory~\cite{...}, like any bridge between previously unrelated subjects, allows ideas and theorems to percolate in both directions.
On the one hand, because any well-behaved homotopy theory admits a model of type theory, we can use formal type-theoretic methods to prove homotopy-theoretic theorems.
On the other hand, examination of these models suggests new principles that can be added to type theory, making it more powerful and expressive, and also increasing the range of homotopy-theoretic theorems that can be proven formally.
So far, there are two important new type-theoretic principles that have been suggested by homotopy-theoretic models.
The first is Voevodsky's \emph{univalence axiom}; this has been discussed in detail elsewhere~\cite{klv:ssetmodel}, and we will have very little to say about it in this paper.
Our concern here is with the second, known as \emph{higher inductive types (HITs)}.

The basic idea of HITs was initially conceived at the Oberwolfach meeting in February 2011 by the present authors along with Bauer and Warren.
The first real application of HITs was the second author's formalized proof that $\pi_1(\circtype)=\lZ$, using a HIT definition of the circle $\circtype$~\cite{ls:pi1s1}.
Since then, many people have contributed to the further development of HITs; we will summarize some of their contributions in \cref{sec:hit-apps} below.
The syntax and use of HITs is explained in detail in Chapter 6 of the Homotopy Type Theory book~\cite{hottbook}, while many of their recent applications can be found in its Chapter 8.

However, what is still missing from the literature is a proof that HITs really do exist in homotopy-theoretic models of type theory, analogous to the proofs in~\cite{klv:ssetmodel,shulman:invdia,shulman:elreedy} that the univalence axiom holds in (some) such models.
This is what we aim to provide in the present paper.
The central ideas of the construction were developed by the authors in the summer of 2011, and disseminated as talks and sketchy notes over the next few years, but have not been written out comprehensively until now.

\subsection{What are HITs?}
\label{sec:what-are-hits}

There are many different ways to motivate HITs.

From a homotopy-theoretic point of view, they provide a way to construct interesting homotopy types in type theory.
Homotopy type theory (with univalence, but without HITs) excels at proving formal theorems about \emph{general} homotopy types, such as the ``5-lemma'' for fibration sequences or an ``unstable octahedral axiom'' for composites of fibrations.
But it suffers from a paucity of ways to obtain \emph{particular} homotopy types, such as spheres, tori, manifolds, Eilenberg--MacLane spaces, etc.
Higher inductive types remedy this situation, and can be thought of a type-theoretic analogue of the basic homotopical notion of \emph{cell complexes}.
They include both ``small, concrete'' cell complexes, such as CW presentations of spheres and tori, and ``large, abstract'' cell complexes such as those appearing in the construction of Postnikov towers and localizations by Quillen's small object argument.
Moreover, they provide a concise language for speaking about the latter that avoids referring explicitly to small objects and transfinite compositions.
(From this perspective, ordinary inductive types are \emph{0-dimensional} cell complexes.)

From a type-theoretic point of view, HITs provide a way to postulate equalities and construct quotients, obviating the need for ``setoids'' and all their corresponding hassles.
Bishop~\cite{bishop:fca} famously claimed that to specify a \emph{set}, one must specify how to construct its elements, and also specify when two such elements are equal.
Ordinary inductive types in type theory excel at specifying how to construct the elements of a set, but leave no flexibility in how to specify their equalities.
The standard solution is to equip each type with a secondary ``type of equalities'', forming a structure called a \emph{setoid}; this mostly works but results in a terrific amount of bookkeeping to carry around the setoid equalities everywhere.
Instead, higher inductive types augment ordinary inductive types with a basic way to ``specify the equalities between elements''.
The resulting equalities are actual equalities in the Leibniz sense, hence require no bookkeeping; they are automatically respected by everything in sight.

From a category-theoretic point of view, HITs provide a concise language for presentations of monads.
It is well-known that categorically, ordinary inductive types are free algebras for polynomial endofunctors.
Here an ``algebra for an endofunctor'' $F$ means nothing more than an object $X$ with a map $FX \to X$.
If $F$ is additionally a \emph{monad}, then we also have ``monad-algebras'', for which the map $FX \to X$ must satisfy associativity and unitality conditions.
In well-behaved categories, every polynomial endofunctor $F$ gives rise to a \emph{free monad} $\freemonad{F}$, so that that $F$-endofunctor-algebras are equivalent to $\freemonad{F}$-monad-algebras; thus we could equally well say that ordinary inductive types are free algebras for free monads.
However, the monads that arise naturally in mathematics are usually not free; but they are \emph{presented}, meaning that they are a colimit in the category of monads of a diagram consisting of free monads.
Higher inductive types, then, provide free algebras for these more general \emph{presented} monads.

Note that the type-theoretic and category-theoretic motivations presented above say nothing about homotopy theory.
(Although they can be easily extended to do so: the homotopical analogue of a setoid is an $\infty$-groupoid in type theory~\cite{coquand...}, and homotopically presented monads are simply colimits in the $(\infty,1)$-category of $(\infty,1)$-monads.)
Indeed, higher inductive types \emph{could} have been invented completely independently of the homotopical interpretation of type theory.
Although historically, it was the first, homotopy-theoretic, motivation which gave rise to them, they are still interesting and highly nontrivial even in Extensional Type Theory, where there is no higher homotopical information.
In particular, they supply well-behaved quotients and free algebras of all sorts, going beyond what exists in elementary toposes, and even beyond what can be constructed in ZF set theory without the axiom of choice, while nevertheless remaining constructive (at least in many, and conjecturally all, senses of the word).


\subsection{Some examples of HITs}
\label{sec:hit-egs}

Recall that an ordinary \emph{inductive type} is specified by some number of \emph{constructors}, which take as input some data (possibly recursively involving the inductive type being defined) and output an element of the inductive type.
For instance, the natural numbers are generated by a constructor \fzero that requires no input and a constructor \fsucc that takes a natural number as input; the unit type is generated by a single constructor \ftt that requires no input; and the empty type is generated by no constructors at all.

Roughly speaking, a \emph{higher} inductive type can have these same sorts of constructor, but also ``constructors'' whose output is not an \emph{element} of the type being defined, but an \emph{equality} between two such elements.
In homotopy type theory, equalities are identified with \emph{paths}, and so we call this new sort of constructor a \emph{path-constructor}.
The old sort of constructors may then be called \emph{point-constructors} for clarity.

It is of central importance that the paths constructed by path-constructors, like the points constructed by point-constructors, are \emph{new} paths, not coinciding with any path that ``already existed''.
For example, consider perhaps the simplest nontrivial HIT, the \textbf{circle} $\circtype$: this is generated by one point-constructor, called \fbase, and one path-constructor, called \floop, which constructs a path from \fbase to \fbase.
Of course, we already knew that \fbase was equal to \fbase, by reflexivity; but the path given by \floop is a \emph{new} such path that is not equal to reflexivity.%
\footnote{More precisely, it is not \textit{a priori} equal to reflexivity.
  Actually \emph{proving} that it is not equal to reflexivity is analogous to proving that the injections of a sum type are disjoint, and requires the univalence axiom; see~\cite{hottbook,ls:pi1s1}.}
From the homotopical point of view, we are describing the circle $\circtype$ as a cell complex with one 0-cell (\fbase) and one 1-cell (\floop).

The existence of \floop also entails the existence of many other paths from \fbase to \fbase; for instance, we can compose \floop with itself (i.e.\ apply the transitivity of equality), or invert it (i.e.\ apply the symmetry of equality), and so on.
Saying that \floop is an inductive generator of $\circtype$ means that \emph{none} of these paths are (\textit{a priori}) equal to each other.
(The theorem that $\pi_1(\circtype)=\lZ$ amounts to showing that, in the presence of the univalence axiom, we get \emph{exactly} the paths $\floop^n$ for $n$ an integer.)

Of course, we can also add paths between points that were not previously equal at all.
For instance, the \textbf{interval} $I$ is generated by two point-constructors, \fzero and \fone, and one path-constructor \fseg which constructs a path from \fzero to \fone.
Unsurprisingly, this turns out to be equivalent to the unit type (but it is not completely boring either, e.g.\ its existence implies function extensionality).

Additionally, since we are interested not only in \emph{whether} two points are equal, but \emph{how many} paths there are between them, we also allow path-constructors which construct \emph{paths between paths}, or \emph{paths between paths between paths}, and so on.
Homotopically, these correspond to cells of higher dimension in a cell complex, and indeed any (finite) cell complex can be presented as a HIT.
For instance, the \textbf{torus} $\torustype$ has one point-constructor \fbase, two path-constructors $\fmerid_1$ and $\fmerid_2$ giving paths from \fbase to itself, and one ``2-path-constructor'' giving a path relating the composites of $\fmerid_1$ and $\fmerid_2$ in both orders.
And the \textbf{2-sphere} $\spheretype 2$ has one point-constructor \fbase and one 2-path-constructor \fsurf giving a path from the \emph{reflexivity} path of \fbase to itself.

The ability to assert equalities also means that we can construct \textbf{colimits} of types.
With ordinary inductive types we can construct coproducts (sum types) and an initial object (the empty type), but not other colimits such as coequalizers or pushouts.
With HITs, however, these are easy to do.

The real power of HITs starts to show itself when we introduce path-constructors with recursive inputs, analogous to recursive point-constructors like \fsucc for the natural numbers.
The first such example is the \textbf{squash}~\cite{nuprlbook} or \textbf{bracket type}~\cite{ab:bracket-types} of a type $A$, which is intended to be a type $\brck{A}$ that contains at most one element, and does so exactly if $A$ has an element.
We can define this as a HIT with one point-constructor that takes as input an element of $A$, and one path-constructor which gives for any two elements $x$ and $y$ \emph{of $\brck{A}$ itself}, a path from $x$ to $y$.
The point-constructor ensures that if $A$ is inhabited then so is $\brck{A}$, while the path-constructor ensures that $\brck{A}$ has no more than one element.%
\footnote{In homotopy type theory, the question is a little more subtle: in addition to ensuring that any two elements of $\brck{A}$ are related by a path, we would want to ensure that any two \emph{paths} are related by a 2-dimensional path, and so on.
  Fortunately, the single path-constructor of $\brck{A}$ is sufficient to ensure this automatically.}

The bracket type is also known as the \textbf{$(-1)$-truncation}: it universally truncates $A$ into a $(-1)$-type, a homotopy type that is contractible if inhabited.
We can also construct $n$-truncations for all higher $n$.
For instance, the \textbf{$0$-truncation} $\trunc 0 A$, also known as $\pi_0(A)$, has the same point-constructor as $\brck{A}$, along with a 2-path-constructor saying that for any two elements $x$ and $y$ of $\trunc 0 A$, and any two paths $p$ and $q$ from $x$ to $y$, there is a path from $p$ to $q$.
In homotopy theory, the $n$-truncations of a type are called its \emph{Postnikov tower}.

By including both recursive point-constructors and recursive path-constructors, we can directly construct \textbf{free algebras} of any desired sort.
For instance, the \textbf{free group} $\freegroup{A}$ on a type $A$
\mswarning{Of course, to make $\freegroup{A}$ a set, we need to truncate it.  Should we mention that or sweep it under the rug?}
is generated by one point-constructor taking input from $A$; three point-constructors taking respectively no input (the identity element), two inputs from $\freegroup{A}$ itself (the multiplication), and one input from $\freegroup{A}$ (the inversion); and various path-constructors asserting the group axioms.
The resulting induction principle of the HIT $\freegroup{A}$ says almost verbatim that it \emph{is} the free group on $A$.
In this way, HITs enable us to ``construct'' free structures of all sorts merely by asserting their universal property.

One final example will serve to suggest the extreme flexibility of HITs.
Let $f:A\to B$ be a given function and $X$ a type, and consider the HIT $\local{f}{X}$ with the following constructors: (1) a point-constructor taking input from $X$, (2) a point-constructor \fext taking as input a function $g:A\to \local{f}{X}$ and an element $b:B$, (3) a path-constructor saying that for any $g:A\to \local{f}{X}$ and $a:A$ we have $\fext(g,f(a))=g(a)$, and (4) a path-constructor saying that for any $h:B\to \local{f}{X}$ and $b:B$ we have $\fext(h\circ f,b)=h(b)$.
\mswarning{Of course, this isn't quite right, it's a qinv rather than an equivalence.}
Then $\local{f}{X}$ is none other than the \textbf{localization} of $X$ at $f$: the universal type equipped with a map from $X$ which is \textbf{$f$-local} in the sense that $(\blank\circ f):(\local{f}{X})^B \to (\local{f}{X})^A$ is an equivalence.
Localizations are ubiquitous in homotopy theory, generally being constructed as transfinite cell complexes with the small object argument; HITs allow us to construct them just like free groups, merely by asserting their universal property.


\subsection{Applications of HITs}
\label{sec:hit-apps}

To show the usefulness and fruitfulness of HITs, we briefly survey some known applications.
Many of these results can be found in~\cite{hottbook}.

A fair amount of work so far has concentrated on reproducing homotopy-theoretic calculations in type theory, such computations of homotopy groups of spheres.
Here the $n^{\mathrm{th}}$ homotopy group $\pi_n(X)$ of a type $X$ (equipped with a basepoint) is defined to be the $0$-truncation of its $n$-fold loop space $\Omega^n X$ (the latter being definable without HITs).
The first such computation, as mentioned above, was the second author's proof that $\pi_1(\circtype)=\lZ$, and also $\pi_n(\circtype)=0$ for $n>1$, by showing that in fact $\Omega \circtype = \lZ$.
Licata~\cite{ls:pi1s1} later improved this proof, isolating a general method now known as ``encode--decode'' for computing with loop spaces of HITs.
Using this method, he and Brunerie calculated $\pi_k(\spheretype n) = 0$ for $k<n$ and $\pi_n(\spheretype n) = \lZ$.
The first author and Brunerie used the Hopf fibration to show $\pi_3(\spheretype 2) = \lZ$, and Brunerie used the James construction to show $\pi_4(\spheretype 3) = \lZ/2$.

HITs have also proven useful in more abstract homotopy-theoretic theorems.
The first author proved the Freudenthal suspension theorem in type theory, and with Licata and Finster generalized it to the Blakers--Massey theorem; the role of HITs being to construct suspensions and pushouts (as well as define homotopy groups by truncation).
The second author proven the van Kampen theorem, and Hou developed the theory of covering spaces.
Licata and Finster~\cite{lf:emspaces} have constructed Eilenberg--MacLane spaces $K(G,n)$, enabling the represented definition of cohomology and verification of the Eilenberg--Steenrod axioms.
Finally, Voevodsky constructed the long exact sequence associated to a fibration, and the second author used this to construct the cohomological Serre spectral sequence.
There is every prospect that this formalization of homotopy theory in type theory will continue fruitfully.

As suggested above, HITs also have applications outside of homotopy theory.
Spitters and Rijke~\cite{rs:hottsets} have used HIT colimits to show that the subcategory of ``sets'' in homotopy type theory is a $\Pi W$-pretopos.
Note that these ``sets'' are just types whose Leibniz equality satisfies UIP, not ``setoids'' equipped with any additional equality structure.
Awodey has constructed a ``cumulative hierarchy'' of ``membership-based sets'' as a HIT, which satisfies a constructive version of the ZF axioms.
Bauer has defined a set of ``Cauchy real numbers'' as a HIT (more precisely, a higher inductive-inductive type) that, unlike a simple quotient of Cauchy sequences, is constructively Cauchy-complete.
And the second author has defined a constructive version of Conway's surreal numbers as a higher inductive-inductive type, generalizing Taylor's ``plump ordinals''.

Finally, HITs may even have direct applications to theoretical computer science.
Angiuli, Morehouse, Licata, and Harper~\cite{amlh:htpy-patch} have used them to model a theory of ``patches'' for version control systems.


\subsection{An outline of this paper}
\label{sec:outline}

Unlike for ordinary inductive types, there is not yet a general presentation of what ``a higher inductive type'' entails.
Some fairly general schemata have been given (some of which we will discuss), but none of them includes all the examples of higher inductive types that have been proposed.
In particular, this means that our semantic construction of HITs cannot yet be phrased as a single theorem.

However, the \emph{methods} that we present in this paper can in fact be applied to all proposed examples of HITs that we are aware of.
For this reason, and also for expositional clarity, the structure of this paper is largely example-based.

\todo{We can wait to write the rest until the rest of the paper settles down.}

\section{Type theory}
\label{sec:type-theory}

In this section we briefly review the basic type theory we will be using.
It has a couple unusual features which enable it to match our models more precisely, but as we will see, they can all be eliminated at the cost of turning some judgmental equalities into propositional ones.

Our base theory is a form of Martin-L\"of dependent type theory \emph{without} universes.
Some of our models (particularly the simplicial set model~\cite{klv:ssetmodel}) have universes, but not all of them are known to, and so since we have little need for universes in this paper, we omit them.
(It should be noted, however, that all the \emph{homotopy-theoretic} results about HITs mentioned in \cref{sec:hit-apps} require the presence of a universe satisfying the univalence axiom.)

The absence of universes means that we need a separate judgment ``$A \type$'' indicating that $A$ is a type.
A type family (or dependent type) indexed by $A$ is then described by a hypothetical judgment $\jd{x:A |- B(x) \type}$.
Any such family has a dependent product $\prd{x:A} B(x)$ satisfying the usual rules, including the $\eta$-rule $f \jdeq \lam{x}f(x)$.
As usual, if $B(x)$ is independent of $x$, we write $A\to B$ for $\prd{x:A} B(x)$.

Besides dependent products\footnote{And coinductive types, which we will not consider here.}, all standard type formers can be regarded as special cases of the general notion of \emph{inductive type} such as in~\cite{gimenez:recursion}.
We will use an \msnote*{Or whatever; I just chose something for now for definiteness}{Agda-like syntax} for describing inductive types.
For instance, we write the natural number type as
\indef{\lN}{
  \fzero : \lN \OR
  \fsucc : \lN \to \lN
}
\msnote{This syntax looks wonky without universes.}
and the dependent pair type $\sm{x:A} B(x)$ as
\indef{\sm{x:A} B(x)}{
  \fpair : \prd{x:A} B(x) \to \sm{x:A} B(x)
}
Note that as usual, the scope of $\prd{x:A}$ extends as far to the right as possible, so that $\prd{x:A} B(x) \to \sm{x:A} B(x)$ means $\prd{x:A} \big(B(x) \to \sm{x:A} B(x)\big)$.

We allow inductive types to contain both \emph{parameters} and \emph{indices}.
Having a \emph{parameter} means essentially that we define a whole family of inductive types all at once, and each member of the family is inductively defined on its own.
For instance, we can define the dependent-pair-type operation with $A$ and $B$ as parameters:
\msnote{What should the syntax be for type parameters in the absence of a universe?}
\indef{\sum \; (A \type) \; (\jd{x:A |- B(x)\type})}{
  \fpair : \prd{x:A} B(x) \to \sm{x:A} B(x)
}
This means that each type $\sm{x:A} B(x)$ has its own induction principle, even though we have defined all of them together at once.
Note that although we have no universes, we allow types and type families to appear as parameters in an inductive definition; this is justified by the coherence theorem of~\cite{lw:localuniv}.
\msnote{Is there a way to specify syntactically what sorts of ``type family parameters'' are allowed?}

Having an \emph{index} means that we define a family of types by induction together, so that rather than each member of the family having an induction principle, the family as a whole has one induction principle.
Syntactically, the difference is that the constructors can take input from one element of the type family and give output in another, such as the standard inductive definition of length-indexed lists (vectors):%
\msnote{Once again, the syntax looks wonky.}
\indeff{\fVec \; (A\type)}{\lN\to\fType}{
  \fnil : \fVec_A(0) \OR
  \fcons : \prd{n:\lN} A \to \fVec_A(n) \to \fVec_A(n+1)
}
Here $A$ is a parameter and $n:\lN$ is an index.

The most important inductively defined family is the \emph{identity type}.\msnote{Mention ML vs PM?}
\indeff{\fId \; (A\type)}{A\to A\to \fType}{
  \refl : \prd{x:A} \id[A]xx
}
The distinguishing feature of \emph{homotopy} type theory is that the identity type $\id[A]xx$ can contain paths other than $\refl$, corresponding to loops in $A$ viewed as a ``space''.
For this reason we will sometimes refer to elements of an identity type as \emph{paths}.

As we will see in \cref{sec:hott-semantics}, it follows directly from the work in~\cite{lw:localuniv} that all of our models contain $\sum$-types and $\fId$-types.
However, in general this is not immediately obvious even for very simple ordinary inductive types such as $\lN$; it will follow as a degenerate case of our semantics for HITs.

As we will see in \cref{sec:syntax}, in order to state the induction principles for HITs we require the notion of \emph{path over a path} or \emph{dependent path}.
This means that given a type $A$ and a type family $B$ over $A$, for points $x,y:A$ and a path $e:\id[A]xy$ and points $u:B(x)$ and $v:B(y)$, we need to know what it means to say that ``$u$ and $v$ are related by a path (or an equality) over $e$''.
Note that the ordinary identity type cannot be applied to $u$ and $v$, since their types $B(x)$ and $B(y)$ are different; instead we need a new ``type of paths from $u$ to $v$ lying over $e$'' which we will write as $\idover[B]{u}{v}{e}$.
There are various ways to define this type, such as:
\begin{enumerate}
\item If we first define the \emph{transport} operation $\transf{e}:B(x) \to B(y)$ (using the eliminator for identity types), then we can define $\idover[B]{u}{v}{e}$ to be $\id[B(y)]{\transf{e}(u)}{v}$.
  This is the definition used by~\cite{hottbook} and~\cite{hottcoq}.\label{item:idover1}
\item We could instead use $\id[B(x)]{u}{\transf{(\opp{e})}(v)}$, where $\opp{e}:\id[A]{y}{x}$ is the inverse path of $e$ (i.e.\ $\opp{(\blank)}$ witnesses the symmetry of equality).\label{item:idover2}
\item We could define $\idover[B]{u}{v}{e}$ by using the eliminator for identity types on $e$, with $\idover[B]{u}{v}{\refl_x}$ defined to be $\id[B(x)]{u}{v}$.
  This is the definition used by~\cite{hottagda}.\label{item:idover3}
\item We could define $\idover[B]{u}{v}{e}$ as an (ordinary) inductive family, with a single constructor saying that for any $x:A$ and $u:B(x)$ we have $\refl_u : \idover[B]{u}{u}{\refl_x}$.\label{item:idover4}
\end{enumerate}
These definitions all produce \emph{equivalent} types, but are not judgmentally identical.
In particular, they have different judgmental behavior: for instance, with~\ref{item:idover1}--\ref{item:idover3} we have $\idover[B]{u}{v}{\refl_x}$ judgmentally equal to $\id[B(x)]{u}{v}$, but with~\ref{item:idover4} this is not necessarily the case.
We will use definition~\ref{item:idover4} because it is more convenient in our models (see below); that is, we define:
\indeff{\fId \; (A\type)\; (\jd{x:A |- B(x)\type})}{\prd{x,y:A} \id[A]xy \to B(x) \to B(y) \to \fType}{
  \refl : \prd{x:A}{u:B(x)} \id[B]{u}{u}_{\refl_x}
}
We will also eventually need to use higher ``path-over-a-path-over-a-path'' types and so on, which we define analogously.

Finally, we include in our type theory a new primitive called \fap (for ``Action on Paths'' or ``APplication to a path''), with the following rules:
\[\inferrule{f:\tprd{x:A} B(x) \\ x:A \\ y:A}{\ap f : \tprd{e:\id[A]xy} \idover[B]{f(x)}{f(y)}{e}}
\qquad
\inferrule{f:\tprd{x:A} B(x) \\ x:A}{\ap f(\refl_x) \jdeq \refl_{f(x)}}
\]
It is, of course, possible to \emph{define} such an operation by identity elimination.
This defined operation, which we denote $\fap'$, plays an essential role in homotopy type theory, as developed in~\cite{hottbook} and elsewhere.
However, all of its occurrences could be replaced by a primitive $\fap$ without any real change, as long as the above two rules are satisfied.
Moreover, the shared computation rules $\ap f(\refl_x) \jdeq \refl_{f(x)}$ and $\app f(\refl_x) \jdeq \refl_{f(x)}$ imply that we always have an inhabitant of $\prd{e:\id[A]xy} \id{\ap f(e)}{\app f(e)}$, i.e.\ $\fap$ and $\fapp$ are propositionally equal.

The reasons for introducing the primitive $\fap$ are that (1) in our models, there is a ``naturally occurring'' operation satisfying the above rules which is not necessarily (judgmentally) identical to the defined $\fapp$, and (2) the rules for HITs take on a simpler form when expressed in terms of the naturally occurring $\fap$ --- specifically, their computation rules are judgmental.
In principle, however, it is always possible to re-express these rules in terms of $\fapp$ by inserting propositional equalities, obtaining a somewhat less convenient set of rules for HITs that we can model without the need for $\fap$.
We will explain this in the simpler cases, although it gets unbearably tedious for higher paths.


\section{Syntax of HITs}
\label{sec:syntax}

In this section we will describe the type-theoretic rules for higher inductive types, so that we know what we want to model in the semantics.
We will begin with simple specific examples and work up to fairly general ones (although, as we have said, a fully general specification of what should count as ``a higher inductive type'' is not yet known).

\subsection{Specification of HITs}
\label{sec:specification}

As mentioned in \cref{sec:hit-egs}, a higher inductive type is specified like an ordinary inductive type, except that in addition to \emph{point-constructors} whose ouput is an \emph{element} of the type being defined, we allow \emph{path-constructors} whose output is a \emph{path} (i.e.\ an equality) in that type.
We extend the syntax for describing inductive types from \cref{sec:type-theory} to include such path-constructors.
For instance, the higher inductive circle $\circtype$ can be written as
\indef{\circtype}{
  \fbase : \circtype \OR
  \floop : \id[\circtype]{\fbase}{\fbase}
}
and the $(-1)$-truncation $\brck{A}$ can be written as
\indef{\brck{A}}{
  \fproj : A \to \brck{A} \OR
  \fsquash : \prd{x,y:\brck{A}} \id[\brck{A}]{x}{y}
}
We may also allow higher path-constructors; for instance, the 2-sphere $\spheretype{2}$ can be written as
\indef{\spheretype{2}}{
  \fbase : \spheretype{2} \OR
  \fsurf : \id[{\id[\spheretype{2}]{\fbase}{\fbase}}]{\refl}{\refl}
}
while the torus $\torustype$ can be written as
\indef{\torustype}{
  \fbase : \torustype \OR
  \fmerid_1 : \id[\torustype]{\fbase}{\fbase} \OR
  \fmerid_2 : \id[\torustype]{\fbase}{\fbase} \OR
  \fsurf : \id[{\id[\torustype]{\fbase}{\fbase}}]{\fmerid_1 \ct \fmerid_2}{\fmerid_2 \ct \fmerid_1}
}
where $p\ct q$ denotes the concatenation of paths (i.e.\ the transitivity of equality).
In general, the \emph{domain} of a path-constructor is of the same form as the domain of a point-constructor (though we will discuss below some possible generalizations of this), while its \emph{codomain} is some iterated path-type of the HIT being constructed.

Note that specifying the codomain of a path-constructor requires specifying terms belonging to the HIT being defined and perhaps also to its iterated path-spaces.
For instance, in $\circtype$ we must specify $\fbase$ and $\fbase$ to be the source and target of the path $\floop$; while in $\torustype$ we must specify $\fbase$ and $\fbase$, and then also ${\fmerid_1 \ct \fmerid_2}$ and ${\fmerid_2 \ct \fmerid_1}$, to give the source and target of $\fsurf$.
These terms will often refer to other point- and perhaps path-constructors, such as $\fbase$ and $\fmerid_1$ and $\fmerid_2$.

This is a departure from ordinary inductive types, in which (at least usually) the type of each constructor must ``stand alone'' without referring to any other constructor.
It immediately presents us with the question of \emph{which} constructors can be referred to in specifying the type of a given constructor.
In this paper, we will always suppose that the constructors (both point- and path-) of a HIT are specified \emph{in an order}, and we allow the type of each constructor to refer only to those constructors appearing \emph{before} it; one can imagine relaxing this restriction, but it is not obvious whether our method for constructing semantics could handle such a relaxation.
Note that since point-constructors have no way to refer to other constructors at all, they might as well all be specified first.

There is an additional technical restriction on the terms ocurring in the codomain of a path-constructor, which we regard as vaguely analogous to the ``strict positivity'' condition on constructor domains: they must be \emph{natural}.
The meaning of this, and its importance, will be explained later.
\msnote{Say something more here once we decide how to deal with fibrancy?}%
(In fact, as we will see, this is one area where our current methods are not completely satisfactory.)

\subsection{Rules for HITs}
\label{sec:rules}

So much for how to \emph{specify} a HIT; how does such a type \emph{behave}?
In general, every type forming operation in type theory comes with \emph{formation}, \emph{introduction}, \emph{elimination}, and \emph{computation} rules.
The above specifications of HITs give us the \textbf{formation} rules easily; in these simple cases, the formation rule is just ``such-and-such type exists'', e.g.
\[ \inferrule{ }{\circtype\type} \]
Formation rules become slighty more complicated when we allow parameters and indices.
For instance, the type $A$ in $\brck{A}$ is best treated as a parameter:
\indef{\brck{\blank} \; (A \type)}{
  \fproj : A \to \brck{A} \OR
  \fsquash : \prd{x,y:\brck{A}} \id[\brck{A}]{x}{y}
}
so that the formation rule becomes
\[ \inferrule{A\type}{\brck{A}\type} \]
However, no new ideas are introduced here by HITs as compared with ordinary inductive types.

The \textbf{introduction rules} for a HIT are also easy: they are just the specified constructors.
For instance, the introduction rules for $\circtype$ say that we have $\fbase:\circtype$ and also $\floop : \id[\circtype]\fbase\fbase$.
It is essential
\msnote{Do we need to say more about why this makes sense?}%
that we regard $\floop$ as an introduction rule for $\circtype$ itself, rather than for $\id[\circtype]\fbase\fbase$, even though it is actually an element of the latter type; this will become clear when we discuss the elimination and computation rules.
Indeed, the type family $\id[\circtype]{\blank}{\blank}$ already has its \emph{own} introduction rule, namely $\refl: \prd{x:\circtype} \id[\circtype]{x}{x}$.

It is when we get to the \textbf{elimination rules} that things get interesting.
Elimination for ordinary inductive types can be specified either with an \emph{induction principle} or with \emph{pattern matching}.
From the perspective of categorical semantics, it appears necessary to regard the induction principle as basic, with pattern matching justified (insofar as possible) by reduction to the induction principle, as in~\cite{gmm:pattern-matching,cdp:without-k}.
It is not yet clear what a general formulation of pattern matching for HITs would look like.
Thus, in this paper we will concentrate on induction principles.

For an ordinary inductive type $W$, the induction principle says that for any type family $B$ over $W$, if we have operations on $B$ that correspond to, and ``live over'', each constructor of $W$, then we can define a function $f:\prd{x:W}B(x)$.
For instance, the induction principle for \lN says that if we have a type family $B$ over \lN equipped with $f_\fzero : B(\fzero)$ and $f_\fsucc : \prd{n:\lN} B(n) \to B(\fsucc(n))$, then we are entitled to a function $\ind{\lN}(f_\fzero,f_\fsucc):\prd{n:\lN} B(n)$.
We expect the induction principle for a HIT to be similar; the only question is what sort of operations on $B$ should be required to correspond to the path-constructors.
This is the role of the \emph{dependent path} type introduced in \cref{sec:type-theory}.

Consider, for example, the interval:
\indef{I}{
  \fzero : I \OR
  \fone : I \OR
  \fseg : \id[I]{\fzero}{\fone}
}
We expect the premises of its induction principle to include $f_\fzero : B(\fzero)$ and $f_\fone : B(\fone)$; but then corresponding to \fseg, we would expect some sort of path relating $f_\fzero$ to $f_\fone$.
We cannot even form a type ``$\id{f_\fzero}{f_\fone}$'' since $f_\fzero$ to $f_\fone$ have different types, but we \emph{can} ask for a dependent path $f_\fseg : \idover[B]{f_\fzero}{f_\fone}{\fseg}$.
Thus, the entire elimination rule for $I$ is
\[\inferrule{\jd{x:I |- B(x) \type} \\ f_\fzero : B(\fzero) \\ f_\fone : B(\fone) \\ f_\fseg : \idover[B]{f_\fzero}{f_\fone}{\fseg}}{\jd{x:I |- \ind{I}(f_\fzero,f_\fone,f_\fseg,x) : B(x)}} \]

The general principle is thus that path-constructors in a HIT correspond to dependent path premises in its induction principle.
For instance, the circle $\circtype$ has the following elimination rule:
\[\inferrule{\jd{x:\circtype |- B(x) \type} \\ f_\fbase : B(\fbase) \\ f_\floop : \idover[B]{f_\fbase}{f_\fbase}{\floop}}{\jd{x:\circtype |- \ind{\circtype}(f_\fbase,f_\floop,x) : B(x)}} \]
Note that in this case it would be possible to \emph{write} the non-dependent path type ``$\id[B(\fbase)]{f_\fbase}{f_\fbase}$'', but that this is \emph{not} the correct type for $f_\floop$.

Path-constructors with nontrivial domain are handled in the expected way, by dependent functions outputting dependent paths.
For instance, the \textbf{suspension} of a type $A$ is defined by
\indef{\susp A}{
  \fnorth : \susp A \OR
  \fsouth : \susp A \OR
  \fmerid : \prd{x:A} \id[\susp A]{\fnorth}{\fsouth}
}
Its induction principle is
\[\inferrule{\jd{x:\susp A |- B(x) \type} \\ f_\fnorth : B(\fnorth) \\ f_\fsouth : B(\fsouth) \\ f_\fmerid : \tprd{x:A} \idover[B]{f_\fnorth}{f_\fsouth}{\fmerid(x)}}
{\jd{x:\susp A |- \ind{\susp A}(f_\fnorth,f_\fsouth,f_\fmerid,x):B(x)}} \]
Similarly, path-constructors with recursive inputs correspond to inductive premises that take inputs from the induction motive.
For instance, the induction principle for the $(-1)$-truncation $\brck{A}$ is
\[\inferrule{\jd{x:\brck A |- B(x) \type} \\ f_\fproj : \tprd{a:A} B(\fproj(a)) \\ f_\fsquash : \tprd{x,y:\brck A}{u:B(x)}{v:B(y)} \idover[B]{u}{v}{\fsquash(x,y)}}
{\jd{x:\brck A |- \ind{\brck A}(f_\fproj,f_\fsquash,x) : B(x)}}
\]
This should be compared with the familiar induction principle for the natural numbers:
\[ \inferrule{\jd{x:\lN |- B(x) \type} \\ f_\fzero : B(\fzero) \\ f_\fsucc : \tprd{x:\lN}{u:B(x)} B(\fsucc(x))}
{\jd{x:\lN |- \ind{\lN}(f_\fzero,f_\fsucc,x) : B(x)}}
\]
In both cases, each recursive argument to a constructor ($\fsucc$ or $\fsquash$) bifurcates into two arguments to the corresponding induction premise, one from the inductive type being defined and one from the induction motive.

Finally, the \textbf{computation rules} say that when we construct a function by induction, and apply it to a constructor, we compute to the arguments of the induction.
For instance, for the natural numbers, we have
\begin{align}
  \ind{\lN}(f_\fzero,f_\fsucc,\fzero) &\jdeq f_\fzero\\
  \ind{\lN}(f_\fzero,f_\fsucc,\fsucc(n)) &\jdeq f_\fsucc(n,\ind{\lN}(f_\fzero,f_\fsucc,n)) 
\end{align}
The only difference with HITs is that in order to ``apply'' a function to a path-constructor, we need to use the operation \fap.
For instance, the computation rules for the interval $I$ are
\begin{align}
  \ind{I}(f_\fzero,f_\fone,f_\fseg,\fzero) &\jdeq f_\fzero\\
  \ind{I}(f_\fzero,f_\fone,f_\fseg,\fone) &\jdeq f_\fone\\
  \ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg) &\jdeq f_\fseg
\end{align}
and the computation rules for the circle $\circtype$ are
\begin{align}
  \ind{\circtype}(f_\fbase,f_\floop,\fbase) &\jdeq f_\fbase\\
  \ap{\ind{\circtype}(f_\fbase,f_\floop)}(\floop) &\jdeq f_\floop.
\end{align}
As for ordinary inductive types, in the computation rules for path-constructors with recursive inputs, the right-hand side involves a recursive call to the function defined by induction.
For instance, the computation rules for $\brck{A}$ are
\begin{align}
  \ind{\brck A}(f_\fproj,f_\fsquash,\fproj(a)) &\jdeq f_\fproj(a)\\
  \ap{\ind{\brck A}(f_\fproj,f_\fsquash)}(\fsquash(x,y)) &\jdeq f_\fsquash(x,y,\ind{\brck A}(f_\fproj,f_\fsquash,x),\ind{\brck A}(f_\fproj,f_\fsquash,y)).
\end{align}

Some additional comments are in order.

\subsection{Judgmental vs propositional computation rules}
\label{sec:comprules}

It is important that the $\fap$ appearing in the computation rules is the primitive operation introduced in \cref{sec:type-theory}.
Since we have a propositional equality $\prd{e:\id[A]xy} \id{\ap f(e)}{\app f(e)}$, the judgmental computation rules for $\fap$ can be transferred into \emph{propositional} computation rules for $\fapp$, e.g.\ for the circle we have an inhabitant of
\[ \fcomp_\floop: \id{\app{\ind{\circtype}(f_\fbase,f_\floop)}(\floop)}{f_\floop}. \]

Most work with HITs so far has used propositional computation rules of this form for path-constructors (with the defined $\fapp$).
One reason for this is that if we want to use the defined $\fapp$ (since a primitive $\fap$ is not available in existing proof assistants), then such propositional rules are all we can get out of our semantics in general.
Another, perhaps more compelling, reason is while that existing proof assistants do not implement HITs natively, there is a hack using ``private types'' due to Licata which enables them to be mimicked, but only with propositional computation rules for path-constructors.

Judgmental computation rules for \emph{point}-constructors are unproblematic from any perspective: they don't require choosing between $\fap$ and $\fapp$, they do hold in the semantics, and they can be implemented in proof assistants using the private-types hack.

Note also that the (judgmental!) computation rules for point-constructors are necessary in order for the computation rules for path-constructors to be well-typed.
For example, by definition we have
\begin{align}
  \ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg) &:
  \idover{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fzero)}{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fone)}{\fseg}\\
  f_\fseg &: \idover{f_\fzero}{f_\fone}{\fseg}.
\end{align}
Only the computation rules for $\fzero$ and $\fone$ ensure that these two types coincide, so that it makes sense to ask whether $\ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg)$ and $f_\fseg$ are equal.
If we had only propositional computation rules such as
\begin{align}
  \fcomp_\fzero &: \id{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fzero)}{f_\fzero}\\
  \fcomp_\fone &: \id{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fone)}{f_\fone}
\end{align}
then in order for the computation rule of \fseg to make sense, we would need to transport along (or, equivalently, compose with) these paths; thus we could at best ask for
\[ \fcomp_\fseg :
\id{\opp{\fcomp_\fzero}\ct \ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg) \ct \fcomp_\fone}{f_\fseg}
\]
Such modifications quickly become quite tedious, so it is fortunate that judgmental computation rules for point-constructors are unproblematic.
However, when considering \emph{higher} path-constructors---or more generally, path-constructors whose source and target refer to previous path-constructors---if we are restricted to propositional computation rules for the previous path-constructors, then there is no escape.
We will mostly avoid this issue in this paper by using the primitive \fap and judgmental computation rules.
\msnote{How much do we want to say about translating along $\fap\sim\fapp$ to get propositional computation rules?}

\subsection{Naturality}
\label{sec:naturality}

When we move on to higher-dimensional HITs, the elimination and computation rules start to involve the requirement of \emph{naturality} that we briefly mentioned before.
Consider the torus type $\torustype$, whose induction principle looks like this:
\[ \inferrule{\jd{x:\torustype |- B(x)\type}\\f_\fbase : B(\fbase) \\
  f_{\fmerid_1} : \idover[B]{f_\fbase}{f_\fbase}{\fmerid_1} \\
  f_{\fmerid_2} : \idover[B]{f_\fbase}{f_\fbase}{\fmerid_2} \\
  f_\fsurf : \idover[{\idover[B]{f_\fbase}{f_\fbase}{\blank}}]{f_{\fmerid_1} \ct f_{\fmerid_2}}{f_{\fmerid_2} \ct f_{\fmerid_1}}{\fsurf}}
{\jd{x:\torustype |- \ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf,x):B(x)}}
\]
Note the type of $f_\fsurf$.
It is a dependent path relative to the type family
\[\jd{p:\id[\torustype]{\fbase}{\fbase} |- {\idover[B]{f_\fbase}{f_\fbase}{p}}\type}\]
between
\begin{align}
  {f_{\fmerid_1} \ct f_{\fmerid_2}} &: \idover[B]{f_\fbase}{f_\fbase}{\fmerid_1\ct\fmerid_2} \qquad\text{and}\\
  {f_{\fmerid_2} \ct f_{\fmerid_1}} &: \idover[B]{f_\fbase}{f_\fbase}{\fmerid_2\ct\fmerid_1}
\end{align}
that lies over
\[\fsurf : \id[\torustype]{\fmerid_1\ct\fmerid_2}{\fmerid_2\ct\fmerid_1}.\]
But what does ``${f_{\fmerid_1} \ct f_{\fmerid_2}}$'' mean?
We need a way to ``compose'' dependent paths $q_1: \idover[B]x y {p_1}$ and $q_2:\idover[B]yz{p_2}$ to get a path $q_1\ct q_2 : \idover[B]{x}{z}{p_1\ct p_2}$.
Such an operation is easy to define (with any definition of dependent paths), but this ``liftability to families'' is a special property of path-concatenation.
As we will see when we construct semantics, it is a sort of \emph{naturality}.

For this reason, we cannot allow just any term to appear as the source or target of a path-constructor; a specific example is given in~\cite[Example 6.13.1]{hottbook} of an attempted ``higher inductive type'' for which it seems impossible to write down an induction principle.
Unfortunately, we do not yet know a \emph{syntactic} criterion on such terms which ensures the requisite naturality and includes all desired examples.

The computation rules for $\torustype$ also involve special properties of path-concatenation, and also some apparently unavoidable propositional equalities.
As in the previous cases, we have
\begin{align}
  \ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf,\fbase) &\jdeq f_\fbase\\
  \ap{\ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf)}(\fmerid_1) &\jdeq f_{\fmerid_1}\\
  \ap{\ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf)}(\fmerid_2) &\jdeq f_{\fmerid_2}
\end{align}
but what about \fsurf?
Writing $f$ for $\ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf)$, we have
\begin{align}
  \ap{\ap{f}}(\fsurf)
  &: \idover[{\idover[B]{f_\fbase}{f_\fbase}{\blank}}]{\ap{f}(\fmerid_1 \ct \fmerid_2)}{\ap{f}(\fmerid_2 \ct \fmerid_1)}{\fsurf}\\
  f_\fsurf &: \idover[{\idover[B]{f_\fbase}{f_\fbase}{\blank}}]{f_{\fmerid_1} \ct f_{\fmerid_2}}{f_{\fmerid_2} \ct f_{\fmerid_1}}{\fsurf}
\end{align}
However, while we have $\ap{f} (\fmerid_1) \jdeq f_{\fmerid_1}$ and $\ap{f} (\fmerid_2) \jdeq f_{\fmerid_2}$ by the previous computation rules, we do not have ${\ap{f}(\fmerid_1 \ct \fmerid_2)}$ judgmentally equal to $\ap{f} (\fmerid_1) \ct \ap{f} (\fmerid_2)$.
The most we can say is that there is a \emph{propositional} equality
\[ \fap_{\ct} : \id[{\idover[B]{f_\fbase}{f_\fbase}{\fmerid_1 \ct \fmerid_2}}]{\ap{f}(\fmerid_1 \ct \fmerid_2)}{\ap{f} (\fmerid_1) \ct \ap{f} (\fmerid_2)}. \]
(This equality is another expression of the \emph{naturality} of path-concatenation, but this time it is only a \emph{propositional} or \emph{pseudo} naturality.)
Thus, the best we can do for a computation rule for $\fsurf$ is an equality
\begin{equation}
  \fcomp_{\fsurf}: \id{\opp{\fap_{\ct}} \ct \ap{\ap{f}}(\fsurf) \ct \fap_{\ct}}
  {f_\fsurf}.\label{eq:fsurf-comp}
\end{equation}
It doesn't make sense to ask for this as a \emph{judgmental} equality, even though the computation rules for $\fmerid_1$ and $\fmerid_2$ are judgmental, because the equality $\fap_{\ct}$ is defined using the elimination principle for identity types and we have little control over its judgmental behavior.
In particular, the equality~\eqref{eq:fsurf-comp} will not generally hold judgmentally in our semantics.

By analogy with our introduction of the primitive \fap, one way to avoid this issue would be to assert that the primitive \fap preserves concatenation judgmentally, i.e.\ that we have $\ap{f}(p\ct q) \jdeq \ap{f}(p) \ct \ap{f}(q)$.
Unfortunately, this is not true in most known semantics (with the \mswarning*{Make sure that's true}{notable exception} of the 1-groupoid model~\cite{hs:gpd-typethy}).

In our construction of semantics, we will see that there turns out to be a sort of partially defined ``primitive path-concatenation'' that is propositionally equal to the usual one, and which is preserved judgmentally by the primitive $\ap{f}$ \emph{when $f$ is defined by induction} (but not for all $f$).
This will be what enables us to construct the \emph{propositional} equality~\eqref{eq:fsurf-comp}, just as the judgmental rules for primitive \fap enable the deduction of propositional rules for the defined \fapp.
However, this more complicated structure is tricky and probably unhelpful to represent syntactically.

In short, although our method of constructing semantics works in simple cases, and ought to work in all cases in principle, the resulting rules for more complicated and higher-dimensional HITs contain proliferating propositional equalities that are tedious and difficult to write down and work with.
We do not yet have a satisfactory solution to this problem; which is not hugely surprising as it is closely related to the coherence problem for weak $\infty$-categories.

\subsection{Higher $W$-types}
\label{sec:higher-w}

We end this section by presenting a general class of HITs which we call \textbf{higher $W$-types}.
Ordinary $W$-types are a sort of parametrized inductive type that are ``universal'', in that all inductive types can be constructed out of $W$-types (and a few other basic type formers such as coproducts and $\Sigma$-types).
We conjecture that higher $W$-types, or something like them, have an analogous property for HITs, but this is unproven; they do certainly include very many examples.

\todo{Define higher $W$-types.}
\msnote{Can you do this?  You've thought about them more than I have.}

\msnote{Where does hub and spoke go?}

\section{Semantics of HoTT}
\label{sec:hott-semantics}

\todo{Recall: comprehension categories, weakly stable structure, \ldots}

\todo{Give specific statement: ``Good model categories model HoTT.''}

\todo{While here, define/discuss any extra conditions on model categories we'll need.}

\todo{Recall: initial-algebra semantics of ITs.}

\section{Semantics of simple HITs}
\label{sec:simple-semantics}

\subsection{Circle}

As we did for inductive types above, to model the circle we first set up a (fibered) category of “algebras”, with a notion of “fibration”, and observe that a stably trivially cofibrant object in this category will model the rules for the circle.
%
In the case of the circle, it is then easy to construct such an object by hand.

\begin{definition}
A \emph{fibrant circle algebra} over $\Gamma \in \E$ is a fibration $X \fibto \Gamma$ equipped with a section $b : \Gamma \to X$, and a map $l : \Gamma \to \paths[\Gamma]{X}$ over $(b,b) : \Gamma \to X \times_\Gamma X$.
%
If $(X,b,l)$ is a fibrant circle algebra over $\Gamma$, then any $f : \Gamma' \to \Gamma$ induces a pullback fibrant circle algebra $f^*(X,b,l) := (f^*X,f^*b,f^*l)$ over $\Gamma'$.
\end{definition}

The formation and introduction rules say exactly that the circle $\circtype$ is a fibrant circle algebra over $1$.

\begin{definition}
A \emph{dependent circle algebra} over a fibrant circle algebra $(X,b,l)$ over $\Gamma$ consists of a fibration $Y \fibto X$, equipped with a map $\bbar : \Gamma \to Y$ over $b$, and a map $\lbar : \Gamma \to \pathsover[\Gamma]{X}{Y}$ over $(\bbar,l,\bbar) : \Gamma \to Y \times_X \paths[\Gamma]{X} \times_X Y$. 
\end{definition}

The premises of the elimination and computation rules, in context $\Gamma$, posit precisely a dependent circle algebra over the pullback of $\circtype$ along $\Gamma \to 1$.

\begin{definition}
A \emph{(strict) section} of a dependent circle algebra $(Y,\bbar,\lbar)$ over $(X,b,l)$, $\Gamma$ is a section $s$ of the fibration $Y \fibto X$, such that $s(b) = \bbar$, $\paths[\Gamma]{s}(l) = \lbar$.

If $Y = (Y,\bbar,\lbar)$ is a dependent circle algebra over $X = (X,b,l)$, in context $\Gamma$, then pulling back along $f : \Gamma' \to \Gamma$ induces a dependent circle algebra $f^*Y$ over $f^*X$.
\end{definition}

The eliminator, together with the (judgemental) computation rules, provide a section for every dependent circle algebra over any pullback of  $\circtype$, along with stability conditions, which we disregard for now but will return to in Lemma~\ref{lemma:circle-coherence} below.
%
Based on this, we define:
\begin{definition}
A fibrant circle algebra is \emph{trivially cofibrant} if every dependent circle algebra over it has a section, and \emph{stably trivially cofibrant} if every pullback of it is trivially cofibrant.
\end{definition}

So far, we have set up these definitions following the syntactic presentation as closely as possible, and not relying on any features particular to the model-categorical setting.
%
However, in this setting---in particular, with strict functoriality of $\paths{-}$---these fit into a rather cleaner big picture:

\begin{definition}
There is an $\E$-indexed category $\Alg[\E]{\circtype}$, with an $\E$-indexed forgetful functor $U : \Alg[\E]{\circtype} \to \Eself$.

Objects of $\Alg[\E]{\circtype}$ consist of triples $(p:X \to \Gamma,b,l)$, as before, but with $p$ not assumed to be a fibration.
%
Maps of $(X',b',l') \to (X,b,l)$ in $\Alg[\E]{\circtype}(\Gamma)$ consist of maps $f : X' \to X$ over $\Gamma$, with $f(b') = b$, $\paths[\Gamma]{f}(l') = l$.

The functor $U$ sends a circle algebra $(X,b,l)$ over $\Gamma$ to its underlying map $p:X \to \Gamma$.

Moreover, $U$ induces an indexed subcategory of \emph{fibrations} in $\Alg[\E]{\circtype}$. 
\end{definition}

With this setting, a fibrant circle algebra over $\Gamma$, as originally defined, is exactly a fibrant object of $\Alg[\E]{\circtype}(\Gamma)$; a dependent circle algebra over $(X,b,l)$ is just a fibration over $(X,b,l)$ in $\Alg[\E]{\circtype}$; and a section of one is exactly a section in the usual sense.

\todo{Construct stable initial algebra as pushout; then, stably triv cof alg as fibrant replacement.}

\todo{State local universes lemma: “weakly stable triv cof alg in $\E$ gives strictly stable circle type in $\E_!$”.}

\subsection{Suspension}

\todo{Same pattern as for circle, but including fibrant replacement, and now only weakly stable}

\todo{Other simple examples?}

\subsection{Propositional truncation}
\todo{$(–1)$-truncation: set up the (now less trivial) category of algebras by hand. Note again that an initial one will model the types.}

\todo{Recall \emph{dialgebras}; recognise the algebras above as (iterated) dialgebras.}

\todo{Recall/give initial dialgebra theorems.  Conclude: we have models of the types.}

\section{Semantics of higher $W$-types}
\label{sec:higherw-semantics}

\todo{Set up endofunctors for iterated dialgebra construction.}

\todo{Note that initial dialgebras model higher $W$-types}

\todo{Note that we have initial dialgebras}

\section{Generalisations}
\label{sec:generalisations}

\todo{Higher path constructors, higher recursive calls, weakly natural sources and targets, induction-induction, induction-recursion, etc.}

\todo{How some of these (and simpler examples) can be reduced to higher W-types?}

\todo{Perhaps give or sketch semantics of some higher I-R type?}

\bibliographystyle{alpha}
\bibliography{basictex/all}

\end{document}
