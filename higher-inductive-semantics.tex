\documentclass{amsart}

\input{decls}
\input{macros}
\setcounter{tocdepth}{1}
\usepackage[utf8]{inputenc}

\title{Semantics of Higher Inductive Types}

\author{Peter LeFanu Lumsdaine}
\author{Michael Shulman}

\begin{document}

\maketitle

\begin{abstract}
The now-standard homotopy-theoretic models of Voevodsky, Awodey--Warren, et al, show that dependent type theory is expressive enough to talk about homotopy-theoretic properties and constructions.
%
However, traditional type theory provides no way to \emph{construct} homotopically non-trivial types.

Higher Inductive Types (HITs) were introduced to remedy this gap (in conjunction with the Univalence Axiom).
%
They generalise ordinary inductive definitions, allowing constructors to produce not only points but \emph{paths} in the posited type.

Here we show that many homotopy-theoretic models of dependent type theory also model HITs, using a generalisation of the initial-algebra semantics of ordinary inductive types.
%
Precisely, we show that \todo{\ldots} .
\end{abstract}


\tableofcontents

\section{Introduction}

The homotopy-theoretic interpretation of constructive type theory~\cite{...}, like any bridge between previously unrelated subjects, allows ideas and theorems to percolate in both directions.
On the one hand, because any well-behaved homotopy theory admits a model of type theory, we can use formal type-theoretic methods to prove homotopy-theoretic theorems.
On the other hand, examination of these models suggests new principles that can be added to type theory, making it more powerful and expressive, and also increasing the range of homotopy-theoretic theorems that can be proven formally.
So far, there are two important new type-theoretic principles that have been suggested by homotopy-theoretic models.
The first is Voevodsky's \emph{univalence axiom}; this has been discussed in detail elsewhere~\cite{klv:ssetmodel}, and we will have very little to say about it in this paper.
Our concern here is with the second, known as \emph{higher inductive types (HITs)}.

The basic idea of HITs was initially conceived at the Oberwolfach meeting in February 2011 by the present authors along with Bauer and Warren.
The first real application of HITs was the second author's formalized proof that $\pi_1(\circtype)=\lZ$, using a HIT definition of the circle $\circtype$~\cite{ls:pi1s1}.
Since then, many people have contributed to the further development of HITs; we will summarize some of their contributions in \cref{sec:hit-apps} below.
The syntax and use of HITs is explained in detail in Chapter 6 of the Homotopy Type Theory book~\cite{hottbook}, while many of their recent applications can be found in its Chapter 8.

However, what is still missing from the literature is a proof that HITs really do exist in homotopy-theoretic models of type theory, analogous to the proofs in~\cite{klv:ssetmodel,shulman:invdia,shulman:elreedy} that the univalence axiom holds in (some) such models.
This is what we aim to provide in the present paper.
The central ideas of the construction were developed by the authors in the summer of 2011, and disseminated as talks and sketchy notes over the next few years, but have not been written out comprehensively until now.

\subsection{What are HITs?}
\label{sec:what-are-hits}

There are many different ways to motivate HITs.

From a homotopy-theoretic point of view, they provide a way to construct interesting homotopy types in type theory.
Homotopy type theory (with univalence, but without HITs) excels at proving formal theorems about \emph{general} homotopy types, such as the ``5-lemma'' for fibration sequences or an ``unstable octahedral axiom'' for composites of fibrations.
But it suffers from a paucity of ways to obtain \emph{particular} homotopy types, such as spheres, tori, manifolds, Eilenberg--MacLane spaces, etc.
Higher inductive types remedy this situation, and can be thought of a type-theoretic analogue of the basic homotopical notion of \emph{cell complexes}.
They include both ``small, concrete'' cell complexes, such as CW presentations of spheres and tori, and ``large, abstract'' cell complexes such as those appearing in the construction of Postnikov towers and localizations by Quillen's small object argument.
Moreover, they provide a concise language for speaking about the latter that avoids referring explicitly to small objects and transfinite compositions.
(From this perspective, ordinary inductive types are \emph{0-dimensional} cell complexes.)

From a type-theoretic point of view, HITs provide a way to postulate equalities and construct quotients, obviating the need for ``setoids'' and all their corresponding hassles.
Bishop~\cite{bishop:fca} famously claimed that to specify a \emph{set}, one must specify how to construct its elements, and also specify when two such elements are equal.
Ordinary inductive types in type theory excel at specifying how to construct the elements of a set, but leave no flexibility in how to specify their equalities.
The standard solution is to equip each type with a secondary ``type of equalities'', forming a structure called a \emph{setoid}; this mostly works but results in a terrific amount of bookkeeping to carry around the setoid equalities everywhere.
Instead, higher inductive types augment ordinary inductive types with a basic way to ``specify the equalities between elements''.
The resulting equalities are actual equalities in the Leibniz sense, hence require no bookkeeping; they are automatically respected by everything in sight.

From a category-theoretic point of view, HITs provide a concise language for presentations of monads.
It is well-known that categorically, ordinary inductive types are free algebras for polynomial endofunctors.
Here an ``algebra for an endofunctor'' $F$ means nothing more than an object $X$ with a map $FX \to X$.
If $F$ is additionally a \emph{monad}, then we also have ``monad-algebras'', for which the map $FX \to X$ must satisfy associativity and unitality conditions.
In well-behaved categories, every polynomial endofunctor $F$ gives rise to a \emph{free monad} $\freemonad{F}$, so that that $F$-endofunctor-algebras are equivalent to $\freemonad{F}$-monad-algebras; thus we could equally well say that ordinary inductive types are free algebras for free monads.
However, the monads that arise naturally in mathematics are usually not free; but they are \emph{presented}, meaning that they are a colimit in the category of monads of a diagram consisting of free monads.
Higher inductive types, then, provide free algebras for these more general \emph{presented} monads.

Note that the type-theoretic and category-theoretic motivations presented above say nothing about homotopy theory.
(Although they can be easily extended to do so: the homotopical analogue of a setoid is an $\infty$-groupoid in type theory~\cite{coquand...}, and homotopically presented monads are simply colimits in the $(\infty,1)$-category of $(\infty,1)$-monads.)
Indeed, higher inductive types \emph{could} have been invented completely independently of the homotopical interpretation of type theory.
Although historically, it was the first, homotopy-theoretic, motivation which gave rise to them, they are still interesting and highly nontrivial even in Extensional Type Theory, where there is no higher homotopical information.
In particular, they supply well-behaved quotients and free algebras of all sorts, going beyond what exists in elementary toposes, and even beyond what can be constructed in ZF set theory without the axiom of choice, while nevertheless remaining constructive (at least in many, and conjecturally all, senses of the word).


\subsection{Some examples of HITs}
\label{sec:hit-egs}

Recall that an ordinary \emph{inductive type} is specified by some number of \emph{constructors}, which take as input some data (possibly recursively involving the inductive type being defined) and output an element of the inductive type.
For instance, the natural numbers are generated by a constructor \fzero that requires no input and a constructor \fsucc that takes a natural number as input; the unit type is generated by a single constructor \ftt that requires no input; and the empty type is generated by no constructors at all.

Roughly speaking, a \emph{higher} inductive type can have these same sorts of constructor, but also ``constructors'' whose output is not an \emph{element} of the type being defined, but an \emph{equality} between two such elements.
In homotopy type theory, equalities are identified with \emph{paths}, and so we call this new sort of constructor a \emph{path-constructor}.
The old sort of constructors may then be called \emph{point-constructors} for clarity.

It is of central importance that the paths constructed by path-constructors, like the points constructed by point-constructors, are \emph{new} paths, not coinciding with any path that ``already existed''.
For example, consider perhaps the simplest nontrivial HIT, the \textbf{circle} $\circtype$: this is generated by one point-constructor, called \fbase, and one path-constructor, called \floop, which constructs a path from \fbase to \fbase.
Of course, we already knew that \fbase was equal to \fbase, by reflexivity; but the path given by \floop is a \emph{new} such path that is not equal to reflexivity.%
\footnote{More precisely, it is not \textit{a priori} equal to reflexivity.
  Actually \emph{proving} that it is not equal to reflexivity is analogous to proving that the injections of a sum type are disjoint, and requires the univalence axiom; see~\cite{hottbook,ls:pi1s1}.}
From the homotopical point of view, we are describing the circle $\circtype$ as a cell complex with one 0-cell (\fbase) and one 1-cell (\floop).

The existence of \floop also entails the existence of many other paths from \fbase to \fbase; for instance, we can compose \floop with itself (i.e.\ apply the transitivity of equality), or invert it (i.e.\ apply the symmetry of equality), and so on.
Saying that \floop is an inductive generator of $\circtype$ means that \emph{none} of these paths are (\textit{a priori}) equal to each other.
(The theorem that $\pi_1(\circtype)=\lZ$ amounts to showing that, in the presence of the univalence axiom, we get \emph{exactly} the paths $\floop^n$ for $n$ an integer.)

Of course, we can also add paths between points that were not previously equal at all.
For instance, the \textbf{interval} $I$ is generated by two point-constructors, \fzero and \fone, and one path-constructor \fseg which constructs a path from \fzero to \fone.
Unsurprisingly, this turns out to be equivalent to the unit type (but it is not completely boring either, e.g.\ its existence implies function extensionality).

Additionally, since we are interested not only in \emph{whether} two points are equal, but \emph{how many} paths there are between them, we also allow path-constructors which construct \emph{paths between paths}, or \emph{paths between paths between paths}, and so on.
Homotopically, these correspond to cells of higher dimension in a cell complex, and indeed any (finite) cell complex can be presented as a HIT.
For instance, the \textbf{torus} $\torustype$ has one point-constructor \fbase, two path-constructors $\fmerid_1$ and $\fmerid_2$ giving paths from \fbase to itself, and one ``2-path-constructor'' giving a path relating the composites of $\fmerid_1$ and $\fmerid_2$ in both orders.
And the \textbf{2-sphere} $\spheretype 2$ has one point-constructor \fbase and one 2-path-constructor \fsurf giving a path from the \emph{reflexivity} path of \fbase to itself.

The ability to assert equalities also means that we can construct \textbf{colimits} of types.
With ordinary inductive types we can construct coproducts (sum types) and an initial object (the empty type), but not other colimits such as coequalizers or pushouts.
With HITs, however, these are easy to do.

The real power of HITs starts to show itself when we introduce path-constructors with recursive inputs, analogous to recursive point-constructors like \fsucc for the natural numbers.
The first such example is the \textbf{squash}~\cite{nuprlbook} or \textbf{bracket type}~\cite{ab:bracket-types} of a type $A$, which is intended to be a type $\brck{A}$ that contains at most one element, and does so exactly if $A$ has an element.
We can define this as a HIT with one point-constructor that takes as input an element of $A$, and one path-constructor which gives for any two elements $x$ and $y$ \emph{of $\brck{A}$ itself}, a path from $x$ to $y$.
The point-constructor ensures that if $A$ is inhabited then so is $\brck{A}$, while the path-constructor ensures that $\brck{A}$ has no more than one element.%
\footnote{In homotopy type theory, the question is a little more subtle: in addition to ensuring that any two elements of $\brck{A}$ are related by a path, we would want to ensure that any two \emph{paths} are related by a 2-dimensional path, and so on.
  Fortunately, the single path-constructor of $\brck{A}$ is sufficient to ensure this automatically.}

The bracket type is also known as the \textbf{$(-1)$-truncation}: it universally truncates $A$ into a $(-1)$-type, a homotopy type that is contractible if inhabited.
We can also construct $n$-truncations for all higher $n$.
For instance, the \textbf{$0$-truncation} $\trunc 0 A$, also known as $\pi_0(A)$, has the same point-constructor as $\brck{A}$, along with a 2-path-constructor saying that for any two elements $x$ and $y$ of $\trunc 0 A$, and any two paths $p$ and $q$ from $x$ to $y$, there is a path from $p$ to $q$.
In homotopy theory, the $n$-truncations of a type are called its \emph{Postnikov tower}.

By including both recursive point-constructors and recursive path-constructors, we can directly construct \textbf{free algebras} of any desired sort.
For instance, the \textbf{free group} $\freegroup{A}$ on a type $A$
\mswarning{Of course, to make $\freegroup{A}$ a set, we need to truncate it.  Should we mention that or sweep it under the rug?}
is generated by one point-constructor taking input from $A$; three point-constructors taking respectively no input (the identity element), two inputs from $\freegroup{A}$ itself (the multiplication), and one input from $\freegroup{A}$ (the inversion); and various path-constructors asserting the group axioms.
The resulting induction principle of the HIT $\freegroup{A}$ says almost verbatim that it \emph{is} the free group on $A$.
In this way, HITs enable us to ``construct'' free structures of all sorts merely by asserting their universal property.

One final example will serve to suggest the extreme flexibility of HITs.
Let $f:A\to B$ be a given function and $X$ a type, and consider the HIT $\local{f}{X}$ with the following constructors: (1) a point-constructor taking input from $X$, (2) a point-constructor \fext taking as input a function $g:A\to \local{f}{X}$ and an element $b:B$, (3) a path-constructor saying that for any $g:A\to \local{f}{X}$ and $a:A$ we have $\fext(g,f(a))=g(a)$, and (4) a path-constructor saying that for any $h:B\to \local{f}{X}$ and $b:B$ we have $\fext(h\circ f,b)=h(b)$.
\mswarning{Of course, this isn't quite right, it's a qinv rather than an equivalence.}
Then $\local{f}{X}$ is none other than the \textbf{localization} of $X$ at $f$: the universal type equipped with a map from $X$ which is \textbf{$f$-local} in the sense that $(\blank\circ f):(\local{f}{X})^B \to (\local{f}{X})^A$ is an equivalence.
Localizations are ubiquitous in homotopy theory, generally being constructed as transfinite cell complexes with the small object argument; HITs allow us to construct them just like free groups, merely by asserting their universal property.


\subsection{Applications of HITs}
\label{sec:hit-apps}

To show the usefulness and fruitfulness of HITs, we briefly survey some known applications.
Many of these results can be found in~\cite{hottbook}.

A fair amount of work so far has concentrated on reproducing homotopy-theoretic calculations in type theory, such computations of homotopy groups of spheres.
Here the $n^{\mathrm{th}}$ homotopy group $\pi_n(X)$ of a type $X$ (equipped with a basepoint) is defined to be the $0$-truncation of its $n$-fold loop space $\Omega^n X$ (the latter being definable without HITs).
The first such computation, as mentioned above, was the second author's proof that $\pi_1(\circtype)=\lZ$, and also $\pi_n(\circtype)=0$ for $n>1$, by showing that in fact $\Omega \circtype = \lZ$.
Licata~\cite{ls:pi1s1} later improved this proof, isolating a general method now known as ``encode--decode'' for computing with loop spaces of HITs.
Using this method, he and Brunerie calculated $\pi_k(\spheretype n) = 0$ for $k<n$ and $\pi_n(\spheretype n) = \lZ$.
The first author and Brunerie used the Hopf fibration to show $\pi_3(\spheretype 2) = \lZ$, and Brunerie used the James construction to show $\pi_4(\spheretype 3) = \lZ/2$.

HITs have also proven useful in more abstract homotopy-theoretic theorems.
The first author proved the Freudenthal suspension theorem in type theory, and with Licata and Finster generalized it to the Blakers--Massey theorem; the role of HITs being to construct suspensions and pushouts (as well as define homotopy groups by truncation).
The second author proven the van Kampen theorem, and Hou developed the theory of covering spaces.
Licata and Finster~\cite{lf:emspaces} have constructed Eilenberg--MacLane spaces $K(G,n)$, enabling the represented definition of cohomology and verification of the Eilenberg--Steenrod axioms.
Finally, Voevodsky constructed the long exact sequence associated to a fibration, and the second author used this to construct the cohomological Serre spectral sequence.
There is every prospect that this formalization of homotopy theory in type theory will continue fruitfully.

As suggested above, HITs also have applications outside of homotopy theory.
Spitters and Rijke~\cite{rs:hottsets} have used HIT colimits to show that the subcategory of ``sets'' in homotopy type theory is a $\Pi W$-pretopos.
Note that these ``sets'' are just types whose Leibniz equality satisfies UIP, not ``setoids'' equipped with any additional equality structure.
Awodey has constructed a ``cumulative hierarchy'' of ``membership-based sets'' as a HIT, which satisfies a constructive version of the ZF axioms.
Bauer has defined a set of ``Cauchy real numbers'' as a HIT (more precisely, a higher inductive-inductive type) that, unlike a simple quotient of Cauchy sequences, is constructively Cauchy-complete.
And the second author has defined a constructive version of Conway's surreal numbers as a higher inductive-inductive type, generalizing Taylor's ``plump ordinals''.

Finally, HITs may even have direct applications to theoretical computer science.
Angiuli, Morehouse, Licata, and Harper~\cite{amlh:htpy-patch} have used them to model a theory of ``patches'' for version control systems.


\subsection{An outline of this paper}
\label{sec:outline}

Unlike for ordinary inductive types, there is not yet a general presentation of what ``a higher inductive type'' entails.
Some fairly general schemata have been given (some of which we will discuss), but none of them includes all the examples of higher inductive types that have been proposed.
In particular, this means that our semantic construction of HITs cannot yet be phrased as a single theorem.

However, the \emph{methods} that we present in this paper can in fact be applied to all proposed examples of HITs that we are aware of.
For this reason, and also for expositional clarity, the structure of this paper is largely example-based.

\todo{We can wait to write the rest until the rest of the paper settles down.}

\section{Type theory}
\label{sec:type-theory}

In this section we briefly describe the basic type theory we will be using, which for technical reasons is a little unusual.

\subsection{The basic theory}
\label{sec:basic-theory}

First of all, we do not include any universes.
Some of our models (particularly the simplicial set model~\cite{klv:ssetmodel}) have universes, but not all of them are known to, and so since we have little need for universes in this paper, we omit them.
(It should be noted, however, that all the \emph{homotopy-theoretic} results about HITs mentioned in \cref{sec:hit-apps} require the presence of a universe satisfying the univalence axiom.
But many models of interest, such as those arising from $(\infty,1)$-toposes, do have a ``weakly Tarski'' universe, and this is conjecturally sufficient for these proofs.)

The absence of universes means that we need a separate judgment ``$A \type$'' indicating that $A$ is a type.
A type family (or dependent type) indexed by $A$ is then described by a hypothetical judgment $\jd{x:A |- B(x) \type}$.
Any such family has a dependent product $\prd{x:A} B(x)$ satisfying the usual rules, including the $\eta$-rule $f \jdeq \lam{x}f(x)$.
As usual, if $B(x)$ is independent of $x$, we write $A\to B$ for $\prd{x:A} B(x)$.

Besides dependent products\footnote{And coinductive types, which we will not consider here.}, all standard type formers can be regarded as special cases of the general notion of \emph{inductive type} such as in~\cite{gimenez:recursion}.
We will use an \msnote*{Or whatever; I just chose something for now for definiteness}{Agda-like syntax} for describing inductive types.
For instance, we write the natural number type as
\indef{\lN}{
  \fzero : \lN \OR
  \fsucc : \lN \to \lN
}
\msnote{This syntax looks wonky without universes.}
and the dependent pair type $\sm{x:A} B(x)$ as
\indef{\sm{x:A} B(x)}{
  \fpair : \prd{x:A} B(x) \to \sm{x:A} B(x)
}
Note that as usual, the scope of $\prd{x:A}$ extends as far to the right as possible, so that $\prd{x:A} B(x) \to \sm{x:A} B(x)$ means $\prd{x:A} \big(B(x) \to \sm{x:A} B(x)\big)$.

We allow inductive types to contain both \emph{parameters} and \emph{indices}.
Having a \emph{parameter} means essentially that we define a whole family of inductive types all at once, and each member of the family is inductively defined on its own.
For instance, we can define the dependent-pair-type operation with $A$ and $B$ as parameters:
\msnote{What should the syntax be for type parameters in the absence of a universe?}
\indef{\sum \; (A \type) \; (\jd{x:A |- B(x)\type})}{
  \fpair : \prd{x:A} B(x) \to \sm{x:A} B(x)
}
This means that each type $\sm{x:A} B(x)$ has its own induction principle, even though we have defined all of them together at once.
Note that although we have no universes, we allow types and type families to appear as parameters
\msnote{There may be an issue here with universe sizes if there are universes.}
 in an inductive definition; this is justified by the coherence theorem of~\cite{lw:localuniv}.
\msnote{Is there a way to specify syntactically what sorts of ``type family parameters'' are allowed?}

Having an \emph{index} means that we define a family of types by induction together, so that rather than each member of the family having an induction principle, the family as a whole has one induction principle.
Syntactically, the difference is that the constructors can take input from one element of the type family and give output in another, such as the standard inductive definition of length-indexed lists (vectors):%
\msnote{Once again, the syntax looks wonky.}
\indeff{\fVec \; (A\type)}{\lN\to\fType}{
  \fnil : \fVec_A(0) \OR
  \fcons : \prd{n:\lN} A \to \fVec_A(n) \to \fVec_A(n+1)
}
Here $A$ is a parameter and $n:\lN$ is an index.

As we will see in \cref{sec:hott-semantics}, it follows directly from the work in~\cite{lw:localuniv} that all of our models contain nonrecursive inductive types such as $\sum$s, disjoint unions $A+B$, and the empty type $\emptyset$.
However, in general it is not immediately obvious that they have even very simple ordinary inductive types such as $\lN$, although some results in this direction can be found in~\cite{klv:ssetmodel,vdbm:wtypes-hott}.
A general theorem about inductive types will follow as a degenerate case of our semantics for \emph{higher} inductive types.

\subsection{Cubical identity types}
\label{sec:cubic-ident-types}

It is common to define the \emph{identity type} as an inductive family such as
\indeff{\fId \; (A\type)}{A\to A\to \fType}{
  \refl : \prd{x:A} \id[A]xx
}
or
\indeff{\fId \; (A\type) (a:A)}{A\to \fType}{
  \refl : \id[A]aa
}
(The first gives rise to the ``Martin-L\"{o}f eliminator'', the second to the ``Paulin-Mohring eliminator''.)
The distinguishing feature of \emph{homotopy} type theory is that the identity type $\id[A]xx$ can contain paths other than $\refl$, corresponding to loops in $A$ viewed as a ``space''.
For this reason we will sometimes refer to elements of an identity type as \emph{paths}.

However, the above definition of identity types is not ideal when discussing HITs, because certain equalities, notably those involving the application of functions to paths, are propositional rather than judgmental.
This makes complicated homotopy-theoretic proofs increasingly difficult, such as $T^2 = S^1\times S^1$~\cite{bl:torus}.
More seriously, it is a substantial obstacle to the semantic methods we plan to employ in this paper, which rely on \emph{strict} algebraic structures in model categories.

For this reason, we will \emph{not} define the identity types as inductive families.
Instead, we follow the route taken by the ``cubical type theory'' of~\cite{bl:cubical}, introducing a basic notion of ``line in a type'' that can be internalized to yield identity types.
Such lines are encoded by a special context of ``dimension variables'' to the left of the ordinary context; thus a particular judgment might look like this:
\[ x\dim, y\dim \cb a:A \pr b:B \]
where $A$ might depend on $x$ and $y$, while $b$ and $B$ might depend on $x$, $y$, and $a$.
The semicolon separates the ``dimension context'' from the ordinary one.
It is helpful (and semantically valid) to think of ``$x\dim$'' as ``$x:I$'' where $I$ is a sort of ``interval type'';
placing such variables in a separate context just simplifies the theory and its semantics.
The theory is ``cubical'' because from this viewpoint a dimension context $x\dim, y\dim, z\dim$ corresponds to a ``cube'' $I\times I\times I$.

The dimension context admits the usual structural rules of exchange, contraction, and weakening, which is just to say that dimension variables behave like ordinary variables; and in addition there are two special values $0$ and $1$ (the ``endpoints of the interval'') that can be substituted for any dimension variable.
We write substitution of dimension variables with angle brackets to distinguish it from ordinary substitution; thus if $x\dim \vdash a:A$ then we have $y\dim \vdash a\dsubst{y}{x} : A\dsubst{y}{x}$ and $\vdash a\dsubst{0}{x} : A\dsubst{0}{x}$.

In this setup, the identity type is defined roughly by ``abstracting over a dimension variable'';
semantically, this corresponds to the intuition that a path space consists of maps out of an interval.
Relative to an ordinary function abstraction, the main wrinkle is that we indicate in the identity type $\id{a}{b}$ the values $a$ and $b$ of the line at $0$ and $1$; semantically this corresponds to asking that $(0,1):1+1 \to I$ be a ``cofibration''.

Specifically, the rule for forming identity types looks just like the one in MLTT, except for the presence of an extra dimension context $\Psi$:
\begin{equation}
\inferrule{\Psi;\Gamma \vdash A \type \\ \Psi;\Gamma \vdash a_0 :A\dsubst0s \\ \Psi;\Gamma \vdash a_1:A\dsubst1s}{\Psi;\Gamma\vdash \id[A]{a_0}{a_1}\type}\label{eq:cubical-idform-nondep}
\end{equation}
(Actually, there is a further enhancement to this which we postpone discussing until later.)
But the rule for introducing terms in an identity type looks like $\lambda$-abstraction:
\[ \inferrule{\Psi,s\dim\cb\Gamma\pr u:A \\ \Psi;\Gamma \vdash u\dsubst0s \jdeq a_0 \\ \Psi;\Gamma \vdash u\dsubst1s \jdeq a_1}{\Psi;\Gamma \vdash \dlam s u : \id[A]{a_0}{a_1}} \]
(we use the modified notation $\dlamsym$ to indicate that it is a different kind of abstraction)
and the rule for elimination looks like application:
\[ \inferrule{\Psi;\Gamma \vdash u:\id[A]{a_0}{a_1} \\ \Psi \vdash r \dim}{\Psi;\Gamma \vdash u\dapp r : A\dsubst{r}{s}} \]
We also have corresponding computation rules:
\[ \inferrule{\Psi,s\dim\cb\Gamma\pr u:A \\ \Psi \vdash r \dim}{\Psi;\Gamma \vdash (\dlam s u)\dapp r \jdeq u\dsubst{r}{s}} \]
\[ \inferrule{\Psi;\Gamma \vdash u:\id[A]{a_0}{a_1}}{\Psi;\Gamma \vdash u\dapp 0 \jdeq a_0}
\hspace{1cm}\inferrule{\Psi;\Gamma \vdash u:\id[A]{a_0}{a_1}}{\Psi;\Gamma \vdash u\dapp 1 \jdeq a_1} \]

As an example of how to use these identity types, we can define the operation \ap (for ``Action on Paths'' or ``APplication to an equality'') associated to a function, which takes a path between points in the domain to a path between their images in the codomain.
Given a function $f:A\to B$ and points $a_0,a_1:A$, we can form\footnote{This entire discussion should really take place in an arbitrary context $\Psi;\Gamma$, but for clarity we omit this from the notation.}
\[ r\dim \cb p:\id[A]{a_0}{a_1} \pr p\dapp r : A. \]
Now, because the ordinary rules of type theory, including ordinary function application, are valid \emph{in any context}, including a nontrivial dimension context, we can form
\[ r\dim \cb p:\id[A]{a_0}{a_1} \pr f(p\dapp r) : B. \]
Now we can abstract over $r$ to obtain
\[ \emptycxt \cb p:\id[A]{a_0}{a_1} \pr \dlam{r} f(p\dapp r) : \id[B]{f(a_0)}{f(a_1)} \]
(where $\emptycxt$ denotes an empty dimension context).
This is valid, according to the introduction rule, because 
\[ (f(p\dapp r))\dsubst0r \jdeq f((p\dapp r)\dsubst0r) \jdeq f(p\dapp 0) \jdeq a_0 \]
and similarly for $1$.
We can thus define $\ap_f(p)$ to be $\dlam{r} f(p\dapp r)$, and $\ap_f$ itself to be $\lam{p}\dlam{r} f(p\dapp r)$.

As is well-known, we can also define $\ap_f$ using the eliminator for $\fId$ defined as an inductive family.
However, the one we obtain from dimension abstraction is better-behaved.
For instance, given also $g:B\to C$, we can compute
\begin{multline*}
\ap_g (\ap_f(p))
\jdeq \ap_g(\dlam{r} f(p\dapp r))
\jdeq \dlam{s} g((\dlam{r} f(p\dapp r))\dapp s)\\
\jdeq \dlam{s} g(f(p\dapp s))
\jdeq \dlam{s} (g \circ f)(p\dapp s)
\jdeq \ap_{g\circ f}(p).
\end{multline*}
This is a \emph{judgmental} equality, whereas for $\ap_f$ defined with the inductive eliminator it would be only propositional (i.e.\ a term in a higher identity type).
Similarly, if we define $\refl_a$ to be the ``constant path'' $\dlam{r} a$, then we have
\[ \ap_f(\refl_a)
\jdeq \dlam{r} f((\dlam{r}a)\dapp r)
\jdeq \dlam{r} f(a)
\jdeq \refl_{f(a)}.\]
This equality does hold judgmentally for the traditional $\ap_f$, so it is good to know that this is still the case for the cubical one.

The real power of cubical identity types, however, comes from their ability to seamlessly represent \emph{dependent} or \emph{heterogeneous} identity types (``dependent paths'' or ``paths over paths''), which are essential when working with HITs.
The idea of dependent paths is that given a type $A$ and a type family $B$ over $A$, for points $x,y:A$ and a path $e:\id[A]xy$ and points $u:B(x)$ and $v:B(y)$, we need to know what it means to say that ``$u$ and $v$ are related by a path (or an equality) over $e$''.
The ordinary identity type cannot be applied to $u$ and $v$, since their types $B(x)$ and $B(y)$ are different; instead we need a new ``type of paths from $u$ to $v$ lying over $e$'' which we will write as $\idover[B]{u}{v}{e}$.
There are various ways to define this type in ordinary type theory, such as:
\begin{enumerate}
\item If we first define the \emph{transport} operation $\transf{e}:B(x) \to B(y)$ (using the eliminator for identity types), then we can define $\idover[B]{u}{v}{e}$ to be $\id[B(y)]{\transf{e}(u)}{v}$.
  This is the definition used by~\cite{hottbook} and~\cite{hottcoq}.\label{item:idover1}
\item We could instead use $\id[B(x)]{u}{\transf{(\opp{e})}(v)}$, where $\opp{e}:\id[A]{y}{x}$ is the inverse path of $e$ (i.e.\ $\opp{(\blank)}$ witnesses the symmetry of equality).\label{item:idover2}
\item We could define $\idover[B]{u}{v}{e}$ by using the eliminator for identity types on $e$, with $\idover[B]{u}{v}{\refl_x}$ defined to be $\id[B(x)]{u}{v}$.
  This is the definition used by~\cite{hottagda}.\label{item:idover3}
\item \msnote{Is this what Dan and Guillaume used in the cubical proof of the torus?}
 We could define $\idover[B]{u}{v}{e}$ as an (ordinary) inductive family, with a single constructor saying that for any $x:A$ and $u:B(x)$ we have $\refl_u : \idover[B]{u}{u}{\refl_x}$.\label{item:idover4}
\end{enumerate}

In cubical type theory, we instead obtain dependent paths by using a simple extension of the formation rule for identity types, in which the type $A$ can depend on the dimension variable:
\[ \inferrule{\Psi,s\dim \cb \Gamma \pr A \type \\ \Psi;\Gamma \vdash a_0 :A\dsubst0s \\ \Psi;\Gamma \vdash a_1:A\dsubst1s}{\Psi;\Gamma\vdash \id[s.A]{a_0}{a_1}\type}\]
Compared to~\eqref{eq:cubical-idform-nondep}, the main difference is the presence of $s\dim$ in the hypothesis $\Psi,s\dim \cb \Gamma \pr A \type$.
If we view identity types as ``function types'' out of the interval, then this corresponds to allowing dependent functions, like the generalization from $A\to B$ to $\prod_{x:A} B(x)$.
To record this dependency of $A$ on $s$, we modify the notation for the identity type to write $\id[s.A]{a_0}{a_1}$ rather than $\id[A]{a_0}{a_1}$, indicating that the dimension variable $s$ may occur free in $A$ but is bound in $\id[s.A]{a_0}{a_1}$.

Now given the setup for dependent paths, i.e. $e:\id[A]xy$ and $u:B(x)$ and $v:B(y)$, we can form
\[ s\dim \vdash B(e\dapp s) \type \]
and therefore
\[ \vdash \id[s.B(e\dapp s)]{u}{v} \]
This is well-typed because
\begin{align*}
B(e\dapp s)\dsubst{0}{s} &\jdeq B(e\dapp 0) \jdeq B(x) \qquad\text{and}\\
B(e\dapp s)\dsubst{1}{s} &\jdeq B(e\dapp 1) \jdeq B(y).
\end{align*}
We thus take $\id[s.B(e\dapp s)]{u}{v}$ as the definition of the dependent path type $\idover[B]{u}{v}{e}$.
This allows us to use the \emph{same} definition of $\ap_f$ in the case when $f$ is a \emph{dependent} function $f:\prod_{x:A} B(x)$: we deduce successively
\begin{align*}
  r\dim \cb p:\id[A]{a_0}{a_1} &\pr p\dapp r : A\\
  r\dim \cb p:\id[A]{a_0}{a_1} &\pr f(p\dapp r) : B(p\dapp r)\\
  \emptycxt \cb p:\id[A]{a_0}{a_1} &\pr \dlam{r} f(p\dapp r) : \id[r.B(p\dapp r)]{f(a_0)}{f(a_1)}.
\end{align*}
But by definition, $\id[r.B(p\dapp r)]{f(a_0)}{f(a_1)}$ is $\idover[B]{f(a_0)}{f(a_1)}{p}$.

As an example of the usefulness of this, note that if $B$ is a constant family, $B(x) \jdeq B$ for all $x$, then our definition of $\idover[B]{u}{v}{e}$ reduces judgmentally to $\id[B]{u}{v}$, and moreover the dependent $\ap_f$ specializes to the non-dependent one.
\emph{None} of the definitions~\ref{item:idover1}--\ref{item:idover4} in plain MLTT have this property, and this tends to cause significant headaches when doing path computations; cubical identity types thus solve this problem as well.

So far, however, we have not explained how the identity types are to inherit all the usual structure: composites of paths and higher paths forming an $\infty$-groupoid structure, transport in type families along paths, etc.
In MLTT, all of these data are derived from the eliminator for $\fId$ defined as an inductive family.
In cubical type theory, all of these data are essentially \emph{postulated} in a uniform way (as cubical ``Kan composition'' or ``Kan filling'' operations), and from them we can derive the usual eliminator of $\fId$ (though with only a propositional computation rule).
We do not want to take the latter route, because the form of the cubical Kan operations appears very specialized to the cubical set model of type theory, whereas we want our type theory to admit semantics in all the standard simplicial models as well (so that we can prove that HITs exist there).
But we do also want our results to apply to the cubical set model as well.
Thus, we take the ``common core'' of the two theories and postulate the inductive eliminator for $\fId$ along with a propositional computation rule for it.\msnote{Not quite sure about this.}
The resulting type theory is not, of course, computationally well-behaved, but that is not our concern here.

It is worth emphasizing that in our \emph{construction} of HITs we do not use this eliminator at all.
Instead the eliminator serves an auxiliary purpose.
For one thing, our verification in \cref{sec:hott-semantics} that the identity types in our models support this can be regarded as a consistency check that our ``identity types'' really deserve that name.
More importantly, the presence of the eliminator allows us to compare our well-behaved $\ap_f$ with the traditional ill-behaved one, which we denote $\ap'_f$.
Since both $\ap_f(\refl_a)$ and $\ap'_f(\refl_a)$ are equal to $\refl_{f(a)}$ (the former judgmentally, the latter only propositionally since our eliminator has a propositional computation rule), we can use the eliminator again to show that they are propositionally equal; that is, we have a term
\[ \jd{a_0:A , a_1:A, p:\id[A]{a_0}{a_1} |- \fapeq(p) : \id[{\id[B]{f(a_0)}{f(a_1)}}]{\ap'_f(p)}{\ap_f(p)}} \]
This, in turn, enables us to translate the rules for our HITs, which involve $\ap_f$, into rules involving $\ap'_f$ instead.
(We will discuss this further in \cref{sec:syntax}.)
These translated rules are more complicated, but they can be stated in plain MLTT.
In this way, the use of cubical type theory can be entirely eliminated from our results, yielding a statement about HITs that exist in a certain class of models of MLTT.

Returning to the (non-)uses of the eliminator, it is true that some more complicated HITs, such as the torus, incorporate the $\infty$-groupoid operations in their definition.
However, for this purpose the operations derived as usual from the eliminator are, like $\ap'_f$, insufficiently well-behaved for our model construction to work.
One solution would be to postulate the cubical Kan operations, as in CTT; but we could also potentially postulate simplicial Kan operations, or $\infty$-groupoid operations in the style of Batanin.
Whatever choice is made, one would then have to show that these operations exist in the models of interest.
We will not investigate this question in detail, but in \cref{??} we will consider the simple example of the torus itself, which hopefully gives an idea for how such an argument might proceed in the general case.


\section{Syntax of HITs}
\label{sec:syntax}

In this section we will describe the type-theoretic rules for higher inductive types, so that we know what we want to model in the semantics.
We will begin with simple specific examples and work up to fairly general ones (although, as we have said, a fully general specification of what should count as ``a higher inductive type'' is not yet known).

\subsection{Specification of HITs}
\label{sec:specification}

As mentioned in \cref{sec:hit-egs}, a higher inductive type is specified like an ordinary inductive type, except that in addition to \emph{point-constructors} whose ouput is an \emph{element} of the type being defined, we allow \emph{path-constructors} whose output is a \emph{path} (i.e.\ an equality) in that type.
We extend the syntax for describing inductive types from \cref{sec:type-theory} to include such path-constructors.
For instance, the higher inductive circle $\circtype$ can be written as
\indef{\circtype}{
  \fbase : \circtype \OR
  \floop : \id[\circtype]{\fbase}{\fbase}
}
and the $(-1)$-truncation $\brck{A}$ can be written as
\indef{\brck{A}}{
  \fproj : A \to \brck{A} \OR
  \fsquash : \prd{x,y:\brck{A}} \id[\brck{A}]{x}{y}
}
We may also allow higher path-constructors; for instance, the 2-sphere $\spheretype{2}$ can be written as
\indef{\spheretype{2}}{
  \fbase : \spheretype{2} \OR
  \fsurf : \id[{\id[\spheretype{2}]{\fbase}{\fbase}}]{\refl}{\refl}
}
while the torus $\torustype$ can be written as
\indef{\torustype}{
  \fbase : \torustype \OR
  \fmerid_1 : \id[\torustype]{\fbase}{\fbase} \OR
  \fmerid_2 : \id[\torustype]{\fbase}{\fbase} \OR
  \fsurf : \id[{\id[\torustype]{\fbase}{\fbase}}]{\fmerid_1 \ct \fmerid_2}{\fmerid_2 \ct \fmerid_1}
}
where $p\ct q$ denotes the concatenation of paths (i.e.\ the transitivity of equality).
In general, the \emph{domain} of a path-constructor is of the same form as the domain of a point-constructor (though we will discuss below some possible generalizations of this), while its \emph{codomain} is some iterated path-type of the HIT being constructed.

Note that specifying the codomain of a path-constructor requires specifying terms belonging to the HIT being defined and perhaps also to its iterated path-spaces.
For instance, in $\circtype$ we must specify $\fbase$ and $\fbase$ to be the source and target of the path $\floop$; while in $\torustype$ we must specify $\fbase$ and $\fbase$, and then also ${\fmerid_1 \ct \fmerid_2}$ and ${\fmerid_2 \ct \fmerid_1}$, to give the source and target of $\fsurf$.
These terms will often refer to other point- and perhaps path-constructors, such as $\fbase$ and $\fmerid_1$ and $\fmerid_2$.

This is a departure from ordinary inductive types, in which (at least usually) the type of each constructor must ``stand alone'' without referring to any other constructor.
It immediately presents us with the question of \emph{which} constructors can be referred to in specifying the type of a given constructor.
In this paper, we will always suppose that the constructors (both point- and path-) of a HIT are specified \emph{in an order}, and we allow the type of each constructor to refer only to those constructors appearing \emph{before} it; one can imagine relaxing this restriction, but it is not obvious whether our method for constructing semantics could handle such a relaxation.
Note that since point-constructors have no way to refer to other constructors at all, they might as well all be specified first.

There is an additional technical restriction on the terms ocurring in the codomain of a path-constructor, which we regard as vaguely analogous to the ``strict positivity'' condition on constructor domains: they must be \emph{natural}.
The meaning of this, and its importance, will be explained later.
\msnote{Say something more here once we decide how to deal with fibrancy?}%
(In fact, as we will see, this is one area where our current methods are not completely satisfactory.)
\msnote{Can we come up with a syntactic condition ensuring naturality?}

\subsection{Rules for HITs}
\label{sec:rules}

So much for how to \emph{specify} a HIT; how does such a type \emph{behave}?
In general, every type forming operation in type theory comes with \emph{formation}, \emph{introduction}, \emph{elimination}, and \emph{computation} rules.
The above specifications of HITs give us the \textbf{formation} rules easily; in these simple cases, the formation rule is just ``such-and-such type exists'', e.g.
\[ \inferrule{ }{\circtype\type} \]
Formation rules become slighty more complicated when we allow parameters and indices.
For instance, the type $A$ in $\brck{A}$ is best treated as a parameter:
\indef{\brck{\blank} \; (A \type)}{
  \fproj : A \to \brck{A} \OR
  \fsquash : \prd{x,y:\brck{A}} \id[\brck{A}]{x}{y}
}
so that the formation rule becomes
\[ \inferrule{A\type}{\brck{A}\type} \]
However, no new ideas are introduced here by HITs as compared with ordinary inductive types.

The \textbf{introduction rules} for a HIT are also easy: they are just the specified constructors.
For instance, the introduction rules for $\circtype$ say that we have $\fbase:\circtype$ and also $\floop : \id[\circtype]\fbase\fbase$.
It is essential
\msnote{Do we need to say more about why this makes sense?}%
that we regard $\floop$ as an introduction rule for $\circtype$ itself, rather than for $\id[\circtype]\fbase\fbase$, even though it is actually an element of the latter type; this will become clear when we discuss the elimination and computation rules.
Indeed, the type family $\id[\circtype]{\blank}{\blank}$ already has its \emph{own} introduction rule, namely $\refl: \prd{x:\circtype} \id[\circtype]{x}{x}$.

It is when we get to the \textbf{elimination rules} that things get interesting.
Elimination for ordinary inductive types can be specified either with an \emph{induction principle} or with \emph{pattern matching}.
From the perspective of categorical semantics, it appears necessary to regard the induction principle as basic, with pattern matching justified (insofar as possible) by reduction to the induction principle, as in~\cite{gmm:pattern-matching,cdp:without-k}.
It is not yet clear what a general formulation of pattern matching for HITs would look like (although cubical type theory makes it seem more likely to be possible).
Thus, in this paper we will concentrate on induction principles.

For an ordinary inductive type $W$, the induction principle says that for any type family $B$ over $W$, if we have operations on $B$ that correspond to, and ``live over'', each constructor of $W$, then we can define a function $f:\prd{x:W}B(x)$.
For instance, the induction principle for \lN says that if we have a type family $B$ over \lN equipped with $f_\fzero : B(\fzero)$ and $f_\fsucc : \prd{n:\lN} B(n) \to B(\fsucc(n))$, then we are entitled to a function $\ind{\lN}(B,f_\fzero,f_\fsucc):\prd{n:\lN} B(n)$.
We expect the induction principle for a HIT to be similar; the only question is what sort of operations on $B$ should be required to correspond to the path-constructors.
This is the role of the \emph{dependent path} type introduced in \cref{sec:type-theory}.

Consider, for example, the interval:
\indef{I}{
  \fzero : I \OR
  \fone : I \OR
  \fseg : \id[I]{\fzero}{\fone}
}
We expect the premises of its induction principle to include $f_\fzero : B(\fzero)$ and $f_\fone : B(\fone)$; but then corresponding to \fseg, we would expect some sort of path relating $f_\fzero$ to $f_\fone$.
We cannot even form a type ``$\id{f_\fzero}{f_\fone}$'' since $f_\fzero$ to $f_\fone$ have different types, but we \emph{can} ask for a dependent path $f_\fseg : \idover[B]{f_\fzero}{f_\fone}{\fseg}$.
Thus, the entire elimination rule for $I$ is
\[\inferrule{\jd{x:I |- B(x) \type} \\ f_\fzero : B(\fzero) \\ f_\fone : B(\fone) \\ f_\fseg : \idover[B]{f_\fzero}{f_\fone}{\fseg}}{\jd{x:I |- \ind{I}(B,f_\fzero,f_\fone,f_\fseg)(x) : B(x)}} \]

The general principle is thus that path-constructors in a HIT correspond to dependent path premises in its induction principle.
For instance, the circle $\circtype$ has the following elimination rule:
\[\inferrule{\jd{x:\circtype |- B(x) \type} \\ f_\fbase : B(\fbase) \\ f_\floop : \idover[B]{f_\fbase}{f_\fbase}{\floop}}{\jd{x:\circtype |- \ind{\circtype}(B,f_\fbase,f_\floop)(x) : B(x)}} \]
Note that in this case it would be possible to \emph{write} the non-dependent path type ``$\id[B(\fbase)]{f_\fbase}{f_\fbase}$'', but that this is \emph{not} the correct type for $f_\floop$.

Path-constructors with nontrivial domain are handled in the expected way, by dependent functions outputting dependent paths.
For instance, the \textbf{suspension} of a type $A$ is defined by
\indef{\susp A}{
  \fnorth : \susp A \OR
  \fsouth : \susp A \OR
  \fmerid : \prd{x:A} \id[\susp A]{\fnorth}{\fsouth}
}
Its induction principle is
\[\inferrule{\jd{x:\susp A |- B(x) \type} \\ f_\fnorth : B(\fnorth) \\ f_\fsouth : B(\fsouth) \\ f_\fmerid : \tprd{x:A} \idover[B]{f_\fnorth}{f_\fsouth}{\fmerid(x)}}
{\jd{x:\susp A |- \ind{\susp A}(B,f_\fnorth,f_\fsouth,f_\fmerid)(x):B(x)}} \]
Similarly, path-constructors with recursive inputs correspond to inductive premises that take inputs from the induction motive.
For instance, the induction principle for the $(-1)$-truncation $\brck{A}$ is
\[\inferrule{\jd{x:\brck A |- B(x) \type} \\ f_\fproj : \tprd{a:A} B(\fproj(a)) \\ f_\fsquash : \tprd{x,y:\brck A}{u:B(x)}{v:B(y)} \idover[B]{u}{v}{\fsquash(x,y)}}
{\jd{x:\brck A |- \ind{\brck A}(B,f_\fproj,f_\fsquash)(x) : B(x)}}
\]
This should be compared with the familiar induction principle for the natural numbers:
\[ \inferrule{\jd{x:\lN |- B(x) \type} \\ f_\fzero : B(\fzero) \\ f_\fsucc : \tprd{x:\lN}{u:B(x)} B(\fsucc(x))}
{\jd{x:\lN |- \ind{\lN}(B,f_\fzero,f_\fsucc)(x) : B(x)}}
\]
In both cases, each recursive argument to a constructor ($\fsucc$ or $\fsquash$) bifurcates into two arguments to the corresponding induction premise, one from the inductive type being defined and one from the induction motive.

For HITs with higher-dimensional path-constructors, such as the 2-sphere and the torus, we require a corresponding notion of higher dependent path.
\msnote{Should probably define that and be precise here.}

Finally, \textbf{computation rules} say that when a function defined by elimination is applied to a form obtained by introduction, the result reduces using the inputs of the elimination.
For example, if $f:\lN \to B$ is defined by recursion from $f_\fzero : B$ and $f_\fsucc : B \to B$, then we have $f(\fzero) \jdeq f_\fzero$ and $f(\fsucc(x)) \jdeq f_\fsucc(f(x))$.

To state similar rules for the path-constructors of HITs, we need the operation $\ap_f$.
For instance, the if $f:\circtype \to B$ is defined from $f_\fbase:B$ and $f_\floop : \id[B]{f_\fbase}{f_\fbase}$, we should have $f(\fbase) \jdeq f_\fbase$ (of course) and $\ap_{f}(\floop) \jdeq f_\floop$.
Note that $\ap_{f}(\floop)$ and $f_\floop$ are both elements of $\id[B]{f_\fbase}{f_\fbase}$, the latter by definition and the former because of the first computation rule.
When $B$ depends on $\circtype$, we need the dependent extension of $\ap_f$ which was discussed in \cref{sec:cubic-ident-types}.
The precise rules are
\[ \inferrule{\jd{x:\circtype |- B(x) \type} \\ f_\fbase : B(\fbase) \\ f_\floop : \idover[B]{f_\fbase}{f_\fbase}{\floop}}{\ind{\circtype}(B,f_\fbase,f_\floop)(\fbase)\jdeq f_\fbase \\ \ap_{\ind{\circtype}(B,f_\fbase,f_\floop)}(\floop) \jdeq f_\floop} \]
Similarly, for the suspension we have
\[\inferrule{\jd{x:\susp A |- B(x) \type} \\ f_\fnorth : B(\fnorth) \\ f_\fsouth : B(\fsouth) \\ f_\fmerid : \tprd{x:A} \idover[B]{f_\fnorth}{f_\fsouth}{\fmerid(x)}}
{\ind{\susp A}(B,f_\fnorth,f_\fsouth,f_\fmerid)(\fnorth) \jdeq f_\fnorth \\
  \ind{\susp A}(B,f_\fnorth,f_\fsouth,f_\fmerid)(\fsouth) \jdeq f_\fsouth \\
  \jd{x:A |- \ap_{\ind{\susp A}(B,f_\fnorth,f_\fsouth,f_\fmerid)}(\fmerid(x)) \jdeq f_\fmerid(x)}} \]
As for ordinary inductive types, in the computation rules for path-constructors with recursive inputs, the right-hand side involves a recursive call to the function defined by induction.
For instance, the computation rules for $\brck{A}$ are
\[\inferrule{\jd{x:\brck A |- B(x) \type} \\ f_\fproj : \tprd{a:A} B(\fproj(a)) \\ f_\fsquash : \tprd{x,y:\brck A}{u:B(x)}{v:B(y)} \idover[B]{u}{v}{\fsquash(x,y)}}
{\jd{a:A |- \ind{\brck A}(B,f_\fproj,f_\fsquash)(\fproj(a)) \jdeq f_\fproj(a)}\\
\jd{x:\brck A , y:\brck A |- \ap_f(\fsquash(x,y)) \jdeq f_\fsquash(x,y,f(x),f(y))}}
\]
(In the last rule we have abbreviated $\ind{\brck A}(B,f_\fproj,f_\fsquash)$ by $f$ for readability.)



\subsection{Judgmental vs propositional computation rules}
\label{sec:comprules}

Note that all of our computation rules are judgmental, even those involving path-constructors and $\ap$.
This is very convenient for applications, and it is what we will get from our semantic construction as well.
It does depend crucially on the fact that we state these rules using the cubical $\ap$ defined by abstraction over lines, rather than the version $\ap'$ defined using the eliminator for identity types: as far as we know the computation rules do \emph{not} hold judgmentally in our models for $\ap'$.
However, as remarked in \cref{sec:cubic-ident-types}, we do have a propositional equality
\[ \jd{a_0:A , a_1:A, p:\id[A]{a_0}{a_1} |- \fapeq(p) : \id[{\id[B]{f(a_0)}{f(a_1)}}]{\ap'_f(p)}{\ap_f(p)}}. \]
Together with our judgmental computation rules for $\ap$, this implies that \emph{propositional} computation rules hold for $\ap'$.
For instance, given a type $B$ with $f_\fbase$ and $f_\floop : \id[B]{f_\fbase}{f_\fbase}$, if we write $f$ for ${\ind{\circtype}(B,f_\fbase,f_\floop)}$, then we have as above 
\[ \ap_f(\floop) \jdeq f_\floop \]
and therefore 
\[ \fapeq(\floop) : \id[B]{\ap'_f(\floop)}{f_\floop} \]
Thus, in MLTT regarded as a fragment of our type theory, we have HITs with judgmental computation rules for point-constructors and propositional computation rules for path-constructors.
Most work with HITs so far has used propositional computation rules of this form for path-constructors (with the defined $\ap'$).
One reason for this is that if we want to use $\ap'$ (since a primitive $\ap$ is not available in existing proof assistants), then such propositional rules are all we can get out of our semantics in general.
Another, perhaps more compelling, reason is while that existing proof assistants do not implement HITs natively, there is a hack using ``private types'' due to Licata~\cite{licata:private-types} which enables them to be mimicked, but only with propositional computation rules for path-constructors.

Judgmental computation rules for \emph{point}-constructors are unproblematic from any perspective: they don't require choosing between $\ap$ and $\ap'$, they do hold in the semantics, and they can be implemented in proof assistants using the private-types hack.

Note also that the (judgmental!) computation rules for point-constructors are necessary in order for the computation rules for path-constructors to be well-typed.
For example, by definition we have
\begin{align}
  \ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg) &:
  \idover{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fzero)}{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fone)}{\fseg}\\
  f_\fseg &: \idover{f_\fzero}{f_\fone}{\fseg}.
\end{align}
Only the computation rules for $\fzero$ and $\fone$ ensure that these two types coincide, so that it makes sense to ask whether $\ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg)$ and $f_\fseg$ are equal.
If we had only propositional computation rules such as
\begin{align}
  \fcomp_\fzero &: \id{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fzero)}{f_\fzero}\\
  \fcomp_\fone &: \id{\ind{I}(f_\fzero,f_\fone,f_\fseg,\fone)}{f_\fone}
\end{align}
then in order for the computation rule of \fseg to make sense, we would need to transport along (or, equivalently, compose with) these paths; thus we could at best ask for
\[ \fcomp_\fseg :
\id{\opp{\fcomp_\fzero}\ct \ap{\ind{I}(f_\fzero,f_\fone,f_\fseg)}(\fseg) \ct \fcomp_\fone}{f_\fseg}
\]
Such modifications quickly become quite tedious, so it is fortunate that judgmental computation rules for point-constructors are unproblematic.
However, when considering \emph{higher} path-constructors---or more generally, path-constructors whose source and target refer to previous path-constructors---if we are restricted to propositional computation rules for the previous path-constructors, then there is no escape.
Such a translation should in principle always be possible, but we will not attempt to describe it in general; we expect it would probably not be worth the effort, since the presence of all these adjusting paths makes HITs with higher path-constructors barely usable in plain MLTT.

It should be noted, though, that one can do quite a lot using only 1-dimensional paths.
For instance, a type equivalent to $\spheretype{2}$ can be defined as $\susp \circtype$, and more generally an $n$-sphere $\spheretype{n}$ can be obtained by iterated suspension.
One can even argue that \emph{all} higher-dimensional path-constructors are reducible to 1-dimensional ones, as in~\cite{lumsdaine:hub-and-spoke} --- although this reduction does not preserve judgmentality of the computation rules, and moreover it uses path-constructors whose domains and codomains are more general than those that we currently know how to deal with in our semantics (specifically, they involve the eliminators for other HITs).

\subsection{Naturality}
\label{sec:naturality}

\todo{Work on this section}

When we move on to higher-dimensional HITs, the elimination and computation rules start to involve the requirement of \emph{naturality} that we briefly mentioned before.
Consider the torus type $\torustype$, whose induction principle looks like this:
\[ \inferrule{\jd{x:\torustype |- B(x)\type}\\f_\fbase : B(\fbase) \\
  f_{\fmerid_1} : \idover[B]{f_\fbase}{f_\fbase}{\fmerid_1} \\
  f_{\fmerid_2} : \idover[B]{f_\fbase}{f_\fbase}{\fmerid_2} \\
  f_\fsurf : \idover[{\idover[B]{f_\fbase}{f_\fbase}{\blank}}]{f_{\fmerid_1} \ct f_{\fmerid_2}}{f_{\fmerid_2} \ct f_{\fmerid_1}}{\fsurf}}
{\jd{x:\torustype |- \ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf,x):B(x)}}
\]
Note the type of $f_\fsurf$.
It is a dependent path relative to the type family
\[\jd{p:\id[\torustype]{\fbase}{\fbase} |- {\idover[B]{f_\fbase}{f_\fbase}{p}}\type}\]
between
\begin{align}
  {f_{\fmerid_1} \ct f_{\fmerid_2}} &: \idover[B]{f_\fbase}{f_\fbase}{\fmerid_1\ct\fmerid_2} \qquad\text{and}\\
  {f_{\fmerid_2} \ct f_{\fmerid_1}} &: \idover[B]{f_\fbase}{f_\fbase}{\fmerid_2\ct\fmerid_1}
\end{align}
that lies over
\[\fsurf : \id[\torustype]{\fmerid_1\ct\fmerid_2}{\fmerid_2\ct\fmerid_1}.\]
But what does ``${f_{\fmerid_1} \ct f_{\fmerid_2}}$'' mean?
We need a way to ``compose'' dependent paths $q_1: \idover[B]x y {p_1}$ and $q_2:\idover[B]yz{p_2}$ to get a path $q_1\ct q_2 : \idover[B]{x}{z}{p_1\ct p_2}$.
Such an operation is easy to define (with any definition of dependent paths), but this ``liftability to families'' is a special property of path-concatenation.
As we will see when we construct semantics, it is a sort of \emph{naturality}.

For this reason, we cannot allow just any term to appear as the source or target of a path-constructor; a specific example is given in~\cite[Example 6.13.1]{hottbook} of an attempted ``higher inductive type'' for which it seems impossible to write down an induction principle.
Unfortunately, we do not yet know a \emph{syntactic} criterion on such terms which ensures the requisite naturality and includes all desired examples.

The computation rules for $\torustype$ also involve special properties of path-concatenation, and also some apparently unavoidable propositional equalities.
As in the previous cases, we have
\begin{align}
  \ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf,\fbase) &\jdeq f_\fbase\\
  \ap{\ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf)}(\fmerid_1) &\jdeq f_{\fmerid_1}\\
  \ap{\ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf)}(\fmerid_2) &\jdeq f_{\fmerid_2}
\end{align}
but what about \fsurf?
Writing $f$ for $\ind{\torustype}(f_\fbase,f_{\fmerid_1},f_{\fmerid_2},f_\fsurf)$, we have
\begin{align}
  \ap{\ap{f}}(\fsurf)
  &: \idover[{\idover[B]{f_\fbase}{f_\fbase}{\blank}}]{\ap{f}(\fmerid_1 \ct \fmerid_2)}{\ap{f}(\fmerid_2 \ct \fmerid_1)}{\fsurf}\\
  f_\fsurf &: \idover[{\idover[B]{f_\fbase}{f_\fbase}{\blank}}]{f_{\fmerid_1} \ct f_{\fmerid_2}}{f_{\fmerid_2} \ct f_{\fmerid_1}}{\fsurf}
\end{align}
However, while we have $\ap{f} (\fmerid_1) \jdeq f_{\fmerid_1}$ and $\ap{f} (\fmerid_2) \jdeq f_{\fmerid_2}$ by the previous computation rules, we do not have ${\ap{f}(\fmerid_1 \ct \fmerid_2)}$ judgmentally equal to $\ap{f} (\fmerid_1) \ct \ap{f} (\fmerid_2)$.
The most we can say is that there is a \emph{propositional} equality
\[ \fap_{\ct} : \id[{\idover[B]{f_\fbase}{f_\fbase}{\fmerid_1 \ct \fmerid_2}}]{\ap{f}(\fmerid_1 \ct \fmerid_2)}{\ap{f} (\fmerid_1) \ct \ap{f} (\fmerid_2)}. \]
(This equality is another expression of the \emph{naturality} of path-concatenation, but this time it is only a \emph{propositional} or \emph{pseudo} naturality.)
Thus, the best we can do for a computation rule for $\fsurf$ is an equality
\begin{equation}
  \fcomp_{\fsurf}: \id{\opp{\fap_{\ct}} \ct \ap{\ap{f}}(\fsurf) \ct \fap_{\ct}}
  {f_\fsurf}.\label{eq:fsurf-comp}
\end{equation}
It doesn't make sense to ask for this as a \emph{judgmental} equality, even though the computation rules for $\fmerid_1$ and $\fmerid_2$ are judgmental, because the equality $\fap_{\ct}$ is defined using the elimination principle for identity types and we have little control over its judgmental behavior.
In particular, the equality~\eqref{eq:fsurf-comp} will not generally hold judgmentally in our semantics.

By analogy with our introduction of the primitive \fap, one way to avoid this issue would be to assert that the primitive \fap preserves concatenation judgmentally, i.e.\ that we have $\ap{f}(p\ct q) \jdeq \ap{f}(p) \ct \ap{f}(q)$.
Unfortunately, this is not true in most known semantics (with the \mswarning*{Make sure that's true}{notable exception} of the 1-groupoid model~\cite{hs:gpd-typethy}).

In our construction of semantics, we will see that there turns out to be a sort of partially defined ``primitive path-concatenation'' that is propositionally equal to the usual one, and which is preserved judgmentally by the primitive $\ap{f}$ \emph{when $f$ is defined by induction} (but not for all $f$).
This will be what enables us to construct the \emph{propositional} equality~\eqref{eq:fsurf-comp}, just as the judgmental rules for primitive \fap enable the deduction of propositional rules for the defined \fapp.
However, this more complicated structure is tricky and probably unhelpful to represent syntactically.

In short, although our method of constructing semantics works in simple cases, and ought to work in all cases in principle, the resulting rules for more complicated and higher-dimensional HITs contain proliferating propositional equalities that are tedious and difficult to write down and work with.
We do not yet have a satisfactory solution to this problem; which is not hugely surprising as it is closely related to the coherence problem for weak $\infty$-categories.


\subsection{Higher $W$-types}
\label{sec:higher-w-types}

We end this section by presenting a general class of HITs which we call \textbf{higher $W$-types}.
Ordinary $W$-types are a sort of parametrized inductive type that are ``universal'', in that all inductive types can be constructed out of $W$-types (and a few other basic type formers such as coproducts and $\Sigma$-types).
We conjecture that higher $W$-types, or something like them, have an analogous property for HITs, but this is unproven; they do certainly include very many examples.

\todo{Define higher $W$-types.}
\msnote{Can you do this?  You've thought about them more than I have.}

\section{Semantics of HoTT}
\label{sec:hott-semantics}

\todo{Recall: comprehension categories, weakly stable structure, \ldots}

\todo{Give specific statement: ``Good model categories model HoTT.''}

\todo{While here, define/discuss any extra conditions on model categories we'll need.}

\todo{Recall: initial-algebra semantics of ITs.}

\section{Semantics of simple HITs}
\label{sec:simple-semantics}

\subsection{Circle}

As we did for inductive types above, to model the circle we first set up a (fibered) category of “algebras”, with a notion of “fibration”, and observe that a stably trivially cofibrant object in this category will model the rules for the circle.
%
In the case of the circle, it is then easy to construct such an object by hand.

\begin{definition}
A \emph{fibrant circle algebra} over $\Gamma \in \E$ is a fibration $X \fibto \Gamma$ equipped with a section $b : \Gamma \to X$, and a map $l : \Gamma \to \paths[\Gamma]{X}$ over $(b,b) : \Gamma \to X \times_\Gamma X$.
%
If $(X,b,l)$ is a fibrant circle algebra over $\Gamma$, then any $f : \Gamma' \to \Gamma$ induces a pullback fibrant circle algebra $f^*(X,b,l) := (f^*X,f^*b,f^*l)$ over $\Gamma'$.
\end{definition}

The formation and introduction rules say exactly that the circle $\circtype$ is a fibrant circle algebra over $1$.

\begin{definition}
A \emph{dependent circle algebra} over a fibrant circle algebra $(X,b,l)$ over $\Gamma$ consists of a fibration $Y \fibto X$, equipped with a map $\bbar : \Gamma \to Y$ over $b$, and a map $\lbar : \Gamma \to \pathsover[\Gamma]{X}{Y}$ over $(\bbar,l,\bbar) : \Gamma \to Y \times_X \paths[\Gamma]{X} \times_X Y$. 
\end{definition}

The premises of the elimination and computation rules, in context $\Gamma$, posit precisely a dependent circle algebra over the pullback of $\circtype$ along $\Gamma \to 1$.

\begin{definition}
A \emph{(strict) section} of a dependent circle algebra $(Y,\bbar,\lbar)$ over $(X,b,l)$, $\Gamma$ is a section $s$ of the fibration $Y \fibto X$, such that $s(b) = \bbar$, $\paths[\Gamma]{s}(l) = \lbar$.

If $Y = (Y,\bbar,\lbar)$ is a dependent circle algebra over $X = (X,b,l)$, in context $\Gamma$, then pulling back along $f : \Gamma' \to \Gamma$ induces a dependent circle algebra $f^*Y$ over $f^*X$.
\end{definition}

The eliminator, together with the (judgemental) computation rules, provide a section for every dependent circle algebra over any pullback of  $\circtype$, along with stability conditions, which we disregard for now but will return to in Lemma~\ref{lemma:circle-coherence} below.
%
Based on this, we define:
\begin{definition}
A fibrant circle algebra is \emph{trivially cofibrant} if every dependent circle algebra over it has a section, and \emph{stably trivially cofibrant} if every pullback of it is trivially cofibrant.
\end{definition}

So far, we have set up these definitions following the syntactic presentation as closely as possible, and not relying on any features particular to the model-categorical setting.
%
However, in this setting---in particular, with strict functoriality of $\paths{-}$---these fit into a rather cleaner big picture:

\begin{definition}
There is an $\E$-indexed category $\Alg[\E]{\circtype}$, with an $\E$-indexed forgetful functor $U : \Alg[\E]{\circtype} \to \Eself$.

Objects of $\Alg[\E]{\circtype}$ consist of triples $(p:X \to \Gamma,b,l)$, as before, but with $p$ not assumed to be a fibration.
%
Maps of $(X',b',l') \to (X,b,l)$ in $\Alg[\E]{\circtype}(\Gamma)$ consist of maps $f : X' \to X$ over $\Gamma$, with $f(b') = b$, $\paths[\Gamma]{f}(l') = l$.

The functor $U$ sends a circle algebra $(X,b,l)$ over $\Gamma$ to its underlying map $p:X \to \Gamma$.

Moreover, $U$ induces an indexed subcategory of \emph{fibrations} in $\Alg[\E]{\circtype}$. 
\end{definition}

With this setting, a fibrant circle algebra over $\Gamma$, as originally defined, is exactly a fibrant object of $\Alg[\E]{\circtype}(\Gamma)$; a dependent circle algebra over $(X,b,l)$ is just a fibration over $(X,b,l)$ in $\Alg[\E]{\circtype}$; and a section of one is exactly a section in the usual sense.

\todo{Construct stable initial algebra as pushout; then, stably triv cof alg as fibrant replacement.}

\todo{State local universes lemma: “weakly stable triv cof alg in $\E$ gives strictly stable circle type in $\E_!$”.}

\subsection{Suspension}

\todo{Same pattern as for circle, but including fibrant replacement, and now only weakly stable}

\todo{Other simple examples?}

\subsection{Propositional truncation}
\todo{$(–1)$-truncation: set up the (now less trivial) category of algebras by hand. Note again that an initial one will model the types.}

\todo{Recall \emph{dialgebras}; recognise the algebras above as (iterated) dialgebras.}

\todo{Recall/give initial dialgebra theorems.  Conclude: we have models of the types.}

\section{Semantics of higher $W$-types}
\label{sec:higherw-semantics}

\todo{Set up endofunctors for iterated dialgebra construction.}

\todo{Note that initial dialgebras model higher $W$-types}

\todo{Note that we have initial dialgebras}

\section{Generalisations}
\label{sec:generalisations}

\todo{Higher path constructors, higher recursive calls, weakly natural sources and targets, induction-induction, induction-recursion, etc.}

\todo{How some of these (and simpler examples) can be reduced to higher W-types?}

\todo{Perhaps give or sketch semantics of some higher I-R type?}

\bibliographystyle{alpha}
\bibliography{basictex/all}

\end{document}
