%%%%%%
% Draft annotations

\usepackage[mode=multiuser,layout=margin,status=draft]{fixme}
\FXRegisterAuthor{ms}{ams}{MS}  % Use \msnote, \mswarning, \mserror, \msfatal
\FXRegisterAuthor{pl}{apl}{PLL} % Use \plnote, \plwarning, \plerror, \plfatal
\fxusetheme{color}

%\newcommand{\comment}[1]{\textcolor{red}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{#1}}

%%%%%%
% Theorem-style environments

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

%%%%%
% Text in typefaces

\autodefs{\fap\fcomp\fzero\fsucc\fpair\ftt\fbase\floop\fone\fseg\fnorth\fsouth\fmerid\fsurf\fext\fdata\fwhere\fId\fEq\fproj\fsquash\frefl\fType\fcxt\fpretype\ftype\fVec\fnil\fcons\fdim\fapeq\fcoeq\fapp\fsplit\ftt\fExt\fpush\fExtn\ffst\fsnd\finl\finr}

\let\E\cE
\let\C\cC
\let\D\cD
\let\P\cP
\let\T\cT
\let\refl\frefl
\let\Ext\fExt
\def\J{\ensuremath{\mathsf{J}}}

%%%%%
% Inductive definitions

\usepackage{xifthen}
\makeatletter
\def\indeff#1#2#3{
  \begin{quote}
    \noindent \fdata ${#1} : {#2}$ \fwhere
    \@indef #3 \OR\OR
  \end{quote}
}
\def\indef#1#2{\indeff{#1}{\fType}{#2}}
\def\@indef#1\OR{\ifthenelse{\isempty{#1}}{}{\\\hspace*{3mm} $#1$ \@indef}}

%%%%%
% General macros

% Judgments
\usepackage{mathpartir}
\newcommand{\cxt}{\;\fcxt}
\newcommand{\pretype}{\;\fpretype}
\newcommand{\fibtype}{\;\ftype}
\renewcommand{\dim}{\;\fdim}
\newcommand{\subst}[2]{[#1/#2]}
\newcommand{\cb}{\,;\,}         % context break  %% TODO: obsolete?
\newcommand{\pr}{\,\vdash\,}
\newcommand{\emptycxt}{\diamond}

\newcommand{\types}{\vdash}
\newcommand{\jd}[2]{#1 \types #2}

% Dimension variables %% TODO: copied directly from dimension variables; reconsider?
\newcommand{\extlamsym}{\mathring{\lambda}}
\newcommand{\extlam}[1]{\dlamsym#1.\,}
\newcommand{\extapp}[2]{ #1 @ #2}

% Dimension variables %% TODO: obsolete?
\newcommand{\dsubst}[2]{\langle #1/#2\rangle}
\newcommand{\dlamsym}{\mathring{\lambda}}
\newcommand{\dlam}[1]{\dlamsym#1.\,}
\newcommand{\dapp}{@}

% Induction
\newcommand{\ind}[1]{\mathsf{ind}_{#1}}

% Categorical/logical constructions
\renewcommand{\id}[3][]{\fId_{#1}(#2,#3)}
\newcommand{\idover}[4][]{\fId_{#1}(#2,#3)_{#4}}
\newcommand{\extn}[3]{\fExtn_{{#1},{#2}}({#3})}
  % Call as \extn{i}{y.C}{x.t}
\newcommand{\paths}[2][]{\cP_{#1}(#2)}
\newcommand{\pathsover}[3][]{\cP_{#1}(#3;#2)}
\let\ap\fap
\newcommand{\circtype}{\ensuremath{S^1}\xspace}
\newcommand{\torustype}{\ensuremath{T^2}\xspace}
\newcommand{\spheretype}[1]{\ensuremath{S^{#1}}\xspace}
\newcommand{\zerotype}{\ensuremath{\mathbf{0}}\xspace}
\newcommand{\zeroelim}[1][]{\mathord{!}_{#1}}
\newcommand{\unittype}{\ensuremath{\mathbf{1}}\xspace}
\newcommand{\bool}{\ensuremath{\mathbf{2}}\xspace}
\newcommand{\bdry}[1]{\delta_{#1}}
\newcommand{\ivl}{{\Delta^1}}
\newcommand{\trunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}\mathclose{}}
\newcommand{\brck}[1]{\trunc{}{#1}}
\newcommand{\freegroup}[1]{F #1}
\newcommand{\local}[2]{L_{#1} #2}
\newcommand{\susp}{\Sigma}
\newcommand{\pair}[2]{\langle #1 , #2 \rangle}
\newcommand{\pairing}{\pair{\blank}{\blank}}
\newcommand{\nulltuple}{\langle \rangle}
\newcommand{\projone}{\ffst} % product/sigma-type projections
\newcommand{\projtwo}{\fsnd}
\newcommand{\copair}[3][]{\left[ #2,#3\right]_{#1}}
\newcommand{\injone}{\finl}
\newcommand{\injtwo}{\finr}

% Strict things
\renewcommand{\eq}[3][]{\fEq_{#1}(#2,#3)}
\renewcommand{\cof}[3]{#1 : #2 \cofto #3}
\newcommand{\cofapp}[2]{#1 \cdot #2 }
\newcommand{\pop}{\Box}         % pushout product

% Categories
\newcommand{\Alg}[2][]{{#2}\text{-}\mathbf{Alg}_{#1}}
\newcommand{\Eself}{\E/\blank}  % self-indexing

% Functors and monads
\newcommand{\freemonad}[1]{\overline{#1}}
\newcommand{\poly}[1]{\mathcal{P}_{#1}}
\newcommand{\idmonad}{\mathcal{ID}}

% Arrows
\newcommand{\fibto}{\to}
\newcommand{\cofto}{\rightarrowtail}

%%%%%
% Originally borrowed from the HoTT Book

% Judgmental equality
\newcommand{\jdeq}{\equiv}

% Introduction by definitions
\newcommand{\defeq}{:\equiv}

% Placeholders
\newcommand{\blank}{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}

% Path reversal
\newcommand{\opp}[1]{\mathord{{#1}^{-1}}}

% Transport
\newcommand{\transf}[1]{\ensuremath{{#1}_{*}}\xspace} % Without argument

%%% Path concatenation (used infix, in diagrammatic order) %%%
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

% Dependent products
\def\prdsym{\textstyle\prod}
%% Call the macro like \prd{x,y:A}{p:x=y} with any number of
%% arguments.  Make sure that whatever comes *after* the call doesn't
%% begin with an open-brace, or it will be parsed as another argument.
\makeatletter
% Currently the macro is configured to produce
%     {\textstyle\prod}(x:A) \; {\textstyle\prod}(y:B),{\ }
% in display-math mode, and
%     \prod_{(x:A)} \prod_{y:B}
% in text-math mode.
% \def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{%
%     \@ifnextchar\sm{\prd@parens{#1}\@eatsm}{%
%         \prd@noparens{#1}}}}
\def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{%
    \@ifnextchar\sm{\prd@parens{#1}\@eatsm}{%
    \@ifnextchar\prd{\prd@parens{#1}\@eatprd}{%
    \@ifnextchar\;{\prd@parens{#1}\@eatsemicolonspace}{%
    \@ifnextchar\\{\prd@parens{#1}\@eatlinebreak}{%
    \@ifnextchar\narrowbreak{\prd@parens{#1}\@eatnarrowbreak}{%
      \prd@noparens{#1}}}}}}}}
\def\prd@parens#1{\@ifnextchar\bgroup%
  {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\prd@parens}%
  {\@ifnextchar\sm%
    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\@eatsm}%
    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}}}
\def\@eatsm\sm{\sm@parens}
\def\prd@noparens#1{\mathchoice{\@dprd@noparens{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}
% Helper macros for three styles
\def\lprd#1{\@ifnextchar\bgroup{\@lprd{#1}\lprd}{\@@lprd{#1}}}
\def\@lprd#1{\mathchoice{{\textstyle\prod}}{\prod}{\prod}{\prod}({\textstyle #1})\;}
\def\@@lprd#1{\mathchoice{{\textstyle\prod}}{\prod}{\prod}{\prod}({\textstyle #1}),\ }
\def\tprd#1{\@tprd{#1}\@ifnextchar\bgroup{\tprd}{}}
\def\@tprd#1{\mathchoice{{\textstyle\prod_{(#1)}}}{\prod_{(#1)}}{\prod_{(#1)}}{\prod_{(#1)}}}
\def\dprd#1{\@dprd{#1}\@ifnextchar\bgroup{\dprd}{}}
\def\@dprd#1{\prod_{(#1)}\,}
\def\@dprd@noparens#1{\prod_{#1}\,}

% Look through spaces and linebreaks
\def\@eatnarrowbreak\narrowbreak{%
  \@ifnextchar\prd{\narrowbreak\@eatprd}{%
    \@ifnextchar\sm{\narrowbreak\@eatsm}{%
      \narrowbreak}}}
\def\@eatlinebreak\\{%
  \@ifnextchar\prd{\\\@eatprd}{%
    \@ifnextchar\sm{\\\@eatsm}{%
      \\}}}
\def\@eatsemicolonspace\;{%
  \@ifnextchar\prd{\;\@eatprd}{%
    \@ifnextchar\sm{\;\@eatsm}{%
      \;}}}

%%% Lambda abstractions.
% Each variable being abstracted over is a separate argument.  If
% there is more than one such argument, they *must* be enclosed in
% braces.  Arguments can be untyped, as in \lam{x}{y}, or typed with a
% colon, as in \lam{x:A}{y:B}. In the latter case, the colons are
% automatically noticed and (with current implementation) the space
% around the colon is reduced.  You can even give more than one variable
% the same type, as in \lam{x,y:A}.
\def\lam#1{{\lambda}\@lamarg#1:\@endlamarg\@ifnextchar\bgroup{.\,\lam}{.\,}}
\def\@lamarg#1:#2\@endlamarg{\if\relax\detokenize{#2}\relax #1\else\@lamvar{\@lameatcolon#2},#1\@endlamvar\fi}
\def\@lamvar#1,#2\@endlamvar{(#2\,{:}\,#1)}
% \def\@lamvar#1,#2{{#2}^{#1}\@ifnextchar,{.\,{\lambda}\@lamvar{#1}}{\let\@endlamvar\relax}}
\def\@lameatcolon#1:{#1}
\let\lamt\lam
% This version silently eats any typing annotation.
\def\lamu#1{{\lambda}\@lamuarg#1:\@endlamuarg\@ifnextchar\bgroup{.\,\lamu}{.\,}}
\def\@lamuarg#1:#2\@endlamuarg{#1}


%%% Dependent sums %%%
\def\smsym{\textstyle\sum}
% Use in the same way as \prd
\def\sm#1{\@ifnextchar\bgroup{\sm@parens{#1}}{%
    \@ifnextchar\prd{\sm@parens{#1}\@eatprd}{%
    \@ifnextchar\sm{\sm@parens{#1}\@eatsm}{%
    \@ifnextchar\;{\sm@parens{#1}\@eatsemicolonspace}{%
    \@ifnextchar\\{\sm@parens{#1}\@eatlinebreak}{%
    \@ifnextchar\narrowbreak{\sm@parens{#1}\@eatnarrowbreak}{%
        \sm@noparens{#1}}}}}}}}
\def\sm@parens#1{\@ifnextchar\bgroup%
  {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\sm@parens}%
  {\@ifnextchar\prd%
    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\@eatprd}%
    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}}}
\def\@eatprd\prd{\prd@parens}
\def\sm@noparens#1{\mathchoice{\@dsm@noparens{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}
\def\lsm#1{\@ifnextchar\bgroup{\@lsm{#1}\lsm}{\@@lsm{#1}}}
\def\@lsm#1{\mathchoice{{\textstyle\sum}}{\sum}{\sum}{\sum}({\textstyle #1})\;}
\def\@@lsm#1{\mathchoice{{\textstyle\sum}}{\sum}{\sum}{\sum}({\textstyle #1}),\ }
\def\tsm#1{\@tsm{#1}\@ifnextchar\bgroup{\tsm}{}}
\def\@tsm#1{\mathchoice{{\textstyle\sum_{(#1)}}}{\sum_{(#1)}}{\sum_{(#1)}}{\sum_{(#1)}}}
\def\dsm#1{\@dsm{#1}\@ifnextchar\bgroup{\dsm}{}}
\def\@dsm#1{\sum_{(#1)}\,}
\def\@dsm@noparens#1{\sum_{#1}\,}


%%%% THEOREM ENVIRONMENTS %%%%

% The cleveref package provides \cref{...} which is like \ref{...}
% except that it automatically inserts the type of the thing you're
% referring to, e.g. it produces "Theorem 3.8" instead of just "3.8"
% (and hyperref makes the whole thing a hyperlink).  This saves a slight amount
% of typing, but more importantly it means that if you decide later on
% that 3.8 should be a Lemma or a Definition instead of a Theorem, you
% don't have to change the name in all the places you referred to it.

% The following hack improves on this by using the same counter for
% all theorem-type environments, so that after Theorem 1.1 comes
% Corollary 1.2 rather than Corollary 1.1.  This makes it much easier
% for the reader to find a particular theorem when flipping through
% the document.
\makeatletter
\def\defthm#1#2#3{%
  %% Ensure all theorem types are numbered with the same counter
  \newaliascnt{#1}{thm}
  \newtheorem{#1}[#1]{#2}
  \aliascntresetthe{#1}
  %% This command tells cleveref's \cref what to call things
  \crefname{#1}{#2}{#3}% following brace must be on separate line to support poorman cleveref sed file
}

% Now define a bunch of theorem-type environments.
\newtheorem{thm}{Theorem}[section]
\crefname{thm}{Theorem}{Theorems}
%\defthm{prop}{Proposition}   % Probably we shouldn't use "Proposition" in this way
\defthm{cor}{Corollary}{Corollaries}
\defthm{lem}{Lemma}{Lemmas}
\defthm{axiom}{Axiom}{Axioms}
% Since definitions and theorems in type theory are synonymous, should
% we actually use the same theoremstyle for them?
\theoremstyle{definition}
\defthm{defn}{Definition}{Definitions}
\theoremstyle{remark}
\defthm{rmk}{Remark}{Remarks}
\defthm{eg}{Example}{Examples}
\defthm{egs}{Examples}{Examples}
\defthm{notes}{Notes}{Notes}

% Display format for sections
\crefformat{section}{\S#2#1#3}
\Crefformat{section}{Section~#2#1#3}
\crefrangeformat{section}{\S\S#3#1#4--#5#2#6}
\Crefrangeformat{section}{Sections~#3#1#4--#5#2#6}
\crefmultiformat{section}{\S\S#2#1#3}{ and~#2#1#3}{, #2#1#3}{ and~#2#1#3}
\Crefmultiformat{section}{Sections~#2#1#3}{ and~#2#1#3}{, #2#1#3}{ and~#2#1#3}
\crefrangemultiformat{section}{\S\S#3#1#4--#5#2#6}{ and~#3#1#4--#5#2#6}{, #3#1#4--#5#2#6}{ and~#3#1#4--#5#2#6}
\Crefrangemultiformat{section}{Sections~#3#1#4--#5#2#6}{ and~#3#1#4--#5#2#6}{, #3#1#4--#5#2#6}{ and~#3#1#4--#5#2#6}

% Also number formulas with the theorem counter
\let\c@equation\c@thm
\numberwithin{equation}{section}

% Local Variables:
% mode: latex
% TeX-master: "higher-inductive-semantics"
% End:
